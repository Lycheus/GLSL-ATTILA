<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0102)http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#VertexAttributeLoadFromShader -->
<html lang="en" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>ATTILA Configuration File Public - AttilaWiki</title>

<meta name="generator" content="MediaWiki 1.16.0beta3">
<link rel="shortcut icon" href="http://attila.ac.upc.edu/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://attila.ac.upc.edu/wiki/opensearch_desc.php" title="AttilaWiki (en)">
<link rel="alternate" type="application/atom+xml" title="AttilaWiki Atom feed" href="http://attila.ac.upc.edu/wiki/index.php?title=Special:RecentChanges&feed=atom">
<link rel="stylesheet" href="http://attila.ac.upc.edu/wiki/skins/vector/main-ltr.css?269" media="screen">
<link rel="stylesheet" href="http://attila.ac.upc.edu/wiki/skins/common/shared.css?269" media="screen">
<link rel="stylesheet" href="http://attila.ac.upc.edu/wiki/skins/common/commonPrint.css?269" media="print">
<link rel="stylesheet" href="http://attila.ac.upc.edu/wiki/index.php?title=MediaWiki:Common.css&usemsgcache=yes&ctype=text%2Fcss&smaxage=18000&action=raw&maxage=18000">
<link rel="stylesheet" href="http://attila.ac.upc.edu/wiki/index.php?title=MediaWiki:Print.css&usemsgcache=yes&ctype=text%2Fcss&smaxage=18000&action=raw&maxage=18000" media="print">
<link rel="stylesheet" href="http://attila.ac.upc.edu/wiki/index.php?title=MediaWiki:Vector.css&usemsgcache=yes&ctype=text%2Fcss&smaxage=18000&action=raw&maxage=18000">
<link rel="stylesheet" href="http://attila.ac.upc.edu/wiki/index.php?title=-&action=raw&maxage=18000&gen=css">
<script>
var skin="vector",
stylepath="/wiki/skins",
wgUrlProtocols="http\\:\\/\\/|https\\:\\/\\/|ftp\\:\\/\\/|irc\\:\\/\\/|gopher\\:\\/\\/|telnet\\:\\/\\/|nntp\\:\\/\\/|worldwind\\:\\/\\/|mailto\\:|news\\:|svn\\:\\/\\/",
wgArticlePath="/wiki/index.php/$1",
wgScriptPath="/wiki",
wgScriptExtension=".php",
wgScript="/wiki/index.php",
wgVariantArticlePath=false,
wgActionPaths={},
wgServer="http://attila.ac.upc.edu",
wgCanonicalNamespace="",
wgCanonicalSpecialPageName=false,
wgNamespaceNumber=0,
wgPageName="ATTILA_Configuration_File_Public",
wgTitle="ATTILA Configuration File Public",
wgAction="view",
wgArticleId=2463,
wgIsArticle=true,
wgUserName=null,
wgUserGroups=null,
wgUserLanguage="en",
wgContentLanguage="en",
wgBreakFrames=false,
wgCurRevisionId=10199,
wgVersion="1.16.0beta3",
wgEnableAPI=true,
wgEnableWriteAPI=true,
wgSeparatorTransformTable=["", ""],
wgDigitTransformTable=["", ""],
wgMainPageTitle="Main Page",
wgFormattedNamespaces={"-2": "Media", "-1": "Special", "0": "", "1": "Talk", "2": "User", "3": "User talk", "4": "AttilaWiki", "5": "AttilaWiki talk", "6": "File", "7": "File talk", "8": "MediaWiki", "9": "MediaWiki talk", "10": "Template", "11": "Template talk", "12": "Help", "13": "Help talk", "14": "Category", "15": "Category talk"},
wgNamespaceIds={"media": -2, "special": -1, "": 0, "talk": 1, "user": 2, "user_talk": 3, "attilawiki": 4, "attilawiki_talk": 5, "file": 6, "file_talk": 7, "mediawiki": 8, "mediawiki_talk": 9, "template": 10, "template_talk": 11, "help": 12, "help_talk": 13, "category": 14, "category_talk": 15, "image": 6, "image_talk": 7},
wgSiteName="AttilaWiki",
wgCategories=[],
wgRestrictionEdit=[],
wgRestrictionMove=[];
</script><script src="./ATTILA Configuration File Public - AttilaWiki_files/wikibits.js"></script>
<script src="./ATTILA Configuration File Public - AttilaWiki_files/jquery.min.js"></script>
<script src="./ATTILA Configuration File Public - AttilaWiki_files/ajax.js"></script>
<script src="./ATTILA Configuration File Public - AttilaWiki_files/ajax(1).js" type="text/javascript"></script>
<script src="./ATTILA Configuration File Public - AttilaWiki_files/ajax2.js" type="text/javascript"></script>
<script type="text/javascript">$=jQuery</script>
<script src="./ATTILA Configuration File Public - AttilaWiki_files/jquery.js" type="text/javascript"></script>
<script src="./ATTILA Configuration File Public - AttilaWiki_files/jquery.sparkline-1.5.js" type="text/javascript"></script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/wiki/skins/vector/csshover.htc")}</style><![endif]-->
<script src="./ATTILA Configuration File Public - AttilaWiki_files/index.php"></script>

</head>
<body class="mediawiki ltr ns-0 ns-subject page-ATTILA_Configuration_File_Public skin-vector">
		<div id="page-base" class="noprint"></div>
		<div id="head-base" class="noprint"></div>
		<!-- content -->
		<div id="content">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<!-- firstHeading -->
			<h1 id="firstHeading" class="firstHeading">ATTILA Configuration File Public</h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id="bodyContent">
				<!-- tagline -->
				<h3 id="siteSub">From AttilaWiki</h3>
				<!-- /tagline -->
				<!-- subtitle -->
				<div id="contentSub"></div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id="jump-to-nav">
					Jump to:<a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#head">navigation</a>,
					<a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#p-search">search</a>
				</div>
				<!-- /jumpto -->
								<!-- bodytext -->
				<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2> <span class="toctoggle">[<a id="togglelink" class="internal" href="javascript:toggleToc()">hide</a>]</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SIMULATOR_section"><span class="tocnumber">1</span> <span class="toctext">SIMULATOR section</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Trace_Parameters"><span class="tocnumber">1.1</span> <span class="toctext">Trace Parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#InputFile"><span class="tocnumber">1.1.1</span> <span class="toctext">InputFile</span></a></li>
<li class="toclevel-3 tocsection-4"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SimCycles"><span class="tocnumber">1.1.2</span> <span class="toctext">SimCycles</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SimFrames"><span class="tocnumber">1.1.3</span> <span class="toctext">SimFrames</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#StartFrame"><span class="tocnumber">1.1.4</span> <span class="toctext">StartFrame</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-7"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Signal_Trace_Parameters"><span class="tocnumber">1.2</span> <span class="toctext">Signal Trace Parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-8"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#DumpSignalTrace"><span class="tocnumber">1.2.1</span> <span class="toctext">DumpSignalTrace</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#StartSignalDump"><span class="tocnumber">1.2.2</span> <span class="toctext">StartSignalDump</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SignalDumpCycles"><span class="tocnumber">1.2.3</span> <span class="toctext">SignalDumpCycles</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SignalDumpFile"><span class="tocnumber">1.2.4</span> <span class="toctext">SignalDumpFile</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Statistics_Parameters"><span class="tocnumber">1.3</span> <span class="toctext">Statistics Parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Statistics"><span class="tocnumber">1.3.1</span> <span class="toctext">Statistics</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#PerCycleStatistics"><span class="tocnumber">1.3.2</span> <span class="toctext">PerCycleStatistics</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#PerFrameStatistics"><span class="tocnumber">1.3.3</span> <span class="toctext">PerFrameStatistics</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#PerBatchStatistics"><span class="tocnumber">1.3.4</span> <span class="toctext">PerBatchStatistics</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#StatisticsRate"><span class="tocnumber">1.3.5</span> <span class="toctext">StatisticsRate</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#StatsFile"><span class="tocnumber">1.3.6</span> <span class="toctext">StatsFile</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#StatsFilePerFrame"><span class="tocnumber">1.3.7</span> <span class="toctext">StatsFilePerFrame</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#StatsFilePerBatch"><span class="tocnumber">1.3.8</span> <span class="toctext">StatsFilePerBatch</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-21"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Stall_Detection_Parameters"><span class="tocnumber">1.4</span> <span class="toctext">Stall Detection Parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-22"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#DetectStalls"><span class="tocnumber">1.4.1</span> <span class="toctext">DetectStalls</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-23"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Fragment_Map_Parameters"><span class="tocnumber">1.5</span> <span class="toctext">Fragment Map Parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-24"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#GenerateFragmentMap"><span class="tocnumber">1.5.1</span> <span class="toctext">GenerateFragmentMap</span></a></li>
<li class="toclevel-3 tocsection-25"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#FragmentMapMode"><span class="tocnumber">1.5.2</span> <span class="toctext">FragmentMapMode</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-26"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#API.2FDriver_Parameters"><span class="tocnumber">1.6</span> <span class="toctext">API/Driver Parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-27"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ForceMSAA"><span class="tocnumber">1.6.1</span> <span class="toctext">ForceMSAA</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MSAASamples"><span class="tocnumber">1.6.2</span> <span class="toctext">MSAASamples</span></a></li>
<li class="toclevel-3 tocsection-29"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ForceFP16ColorBuffer"><span class="tocnumber">1.6.3</span> <span class="toctext">ForceFP16ColorBuffer</span></a></li>
<li class="toclevel-3 tocsection-30"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#DoubleBuffer"><span class="tocnumber">1.6.4</span> <span class="toctext">DoubleBuffer</span></a></li>
<li class="toclevel-3 tocsection-31"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#EnableDriverShaderTranslation"><span class="tocnumber">1.6.5</span> <span class="toctext">EnableDriverShaderTranslation</span></a></li>
<li class="toclevel-3 tocsection-32"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#UseACD"><span class="tocnumber">1.6.6</span> <span class="toctext">UseACD</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-33"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Dynamic_Memory_Parameters"><span class="tocnumber">1.7</span> <span class="toctext">Dynamic Memory Parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-34"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ObjectSize0"><span class="tocnumber">1.7.1</span> <span class="toctext">ObjectSize0</span></a></li>
<li class="toclevel-3 tocsection-35"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BucketSize0"><span class="tocnumber">1.7.2</span> <span class="toctext">BucketSize0</span></a></li>
<li class="toclevel-3 tocsection-36"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ObjectSize1"><span class="tocnumber">1.7.3</span> <span class="toctext">ObjectSize1</span></a></li>
<li class="toclevel-3 tocsection-37"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BucketSize1"><span class="tocnumber">1.7.4</span> <span class="toctext">BucketSize1</span></a></li>
<li class="toclevel-3 tocsection-38"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ObjectSize2"><span class="tocnumber">1.7.5</span> <span class="toctext">ObjectSize2</span></a></li>
<li class="toclevel-3 tocsection-39"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BucketSize2"><span class="tocnumber">1.7.6</span> <span class="toctext">BucketSize2</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-40"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#GPU_section"><span class="tocnumber">2</span> <span class="toctext">GPU section</span></a>
<ul>
<li class="toclevel-2 tocsection-41"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#NumVertexShaders"><span class="tocnumber">2.1</span> <span class="toctext">NumVertexShaders</span></a></li>
<li class="toclevel-2 tocsection-42"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#NumFragmentShaders"><span class="tocnumber">2.2</span> <span class="toctext">NumFragmentShaders</span></a></li>
<li class="toclevel-2 tocsection-43"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#NumStampPipes"><span class="tocnumber">2.3</span> <span class="toctext">NumStampPipes</span></a></li>
<li class="toclevel-2 tocsection-44"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#GPUClock"><span class="tocnumber">2.4</span> <span class="toctext">GPUClock</span></a></li>
<li class="toclevel-2 tocsection-45"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ShaderClock"><span class="tocnumber">2.5</span> <span class="toctext">ShaderClock</span></a></li>
<li class="toclevel-2 tocsection-46"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MemoryClock"><span class="tocnumber">2.6</span> <span class="toctext">MemoryClock</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-47"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#COMMANDPROCESSOR_section"><span class="tocnumber">3</span> <span class="toctext">COMMANDPROCESSOR section</span></a>
<ul>
<li class="toclevel-2 tocsection-48"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#PipelinedBatchRendering"><span class="tocnumber">3.1</span> <span class="toctext">PipelinedBatchRendering</span></a></li>
<li class="toclevel-2 tocsection-49"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#DumpShaderPrograms"><span class="tocnumber">3.2</span> <span class="toctext">DumpShaderPrograms</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-50"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MEMORYCONTROLLER"><span class="tocnumber">4</span> <span class="toctext">MEMORYCONTROLLER</span></a>
<ul>
<li class="toclevel-2 tocsection-51"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Common_parameters"><span class="tocnumber">4.1</span> <span class="toctext">Common parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-52"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MemorySize"><span class="tocnumber">4.1.1</span> <span class="toctext">MemorySize</span></a></li>
<li class="toclevel-3 tocsection-53"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MappedMemorySize"><span class="tocnumber">4.1.2</span> <span class="toctext">MappedMemorySize</span></a></li>
<li class="toclevel-3 tocsection-54"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BurstLength"><span class="tocnumber">4.1.3</span> <span class="toctext">BurstLength</span></a></li>
<li class="toclevel-3 tocsection-55"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MaxConsecutiveReads"><span class="tocnumber">4.1.4</span> <span class="toctext">MaxConsecutiveReads</span></a></li>
<li class="toclevel-3 tocsection-56"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MaxConsecutiveWrites"><span class="tocnumber">4.1.5</span> <span class="toctext">MaxConsecutiveWrites</span></a></li>
<li class="toclevel-3 tocsection-57"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#CommandProcessorBusWidth"><span class="tocnumber">4.1.6</span> <span class="toctext">CommandProcessorBusWidth</span></a></li>
<li class="toclevel-3 tocsection-58"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#StreamerFetchBusWidth"><span class="tocnumber">4.1.7</span> <span class="toctext">StreamerFetchBusWidth</span></a></li>
<li class="toclevel-3 tocsection-59"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#StreamerLoaderBusWidth"><span class="tocnumber">4.1.8</span> <span class="toctext">StreamerLoaderBusWidth</span></a></li>
<li class="toclevel-3 tocsection-60"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ZStencilBusWidth"><span class="tocnumber">4.1.9</span> <span class="toctext">ZStencilBusWidth</span></a></li>
<li class="toclevel-3 tocsection-61"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ColorWriteBusWidth"><span class="tocnumber">4.1.10</span> <span class="toctext">ColorWriteBusWidth</span></a></li>
<li class="toclevel-3 tocsection-62"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#DACBusWidth"><span class="tocnumber">4.1.11</span> <span class="toctext">DACBusWidth</span></a></li>
<li class="toclevel-3 tocsection-63"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureUnitBusWidth"><span class="tocnumber">4.1.12</span> <span class="toctext">TextureUnitBusWidth</span></a></li>
<li class="toclevel-3 tocsection-64"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ReadBufferLines"><span class="tocnumber">4.1.13</span> <span class="toctext">ReadBufferLines</span></a></li>
<li class="toclevel-3 tocsection-65"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#WriteBufferLines"><span class="tocnumber">4.1.14</span> <span class="toctext">WriteBufferLines</span></a></li>
<li class="toclevel-3 tocsection-66"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#RequestQueueSize"><span class="tocnumber">4.1.15</span> <span class="toctext">RequestQueueSize</span></a></li>
<li class="toclevel-3 tocsection-67"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ServiceQueueSize"><span class="tocnumber">4.1.16</span> <span class="toctext">ServiceQueueSize</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-68"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Legacy_Memory_Controller_parameters"><span class="tocnumber">4.2</span> <span class="toctext">Legacy Memory Controller parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-69"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MemoryClockMultiplier"><span class="tocnumber">4.2.1</span> <span class="toctext">MemoryClockMultiplier</span></a></li>
<li class="toclevel-3 tocsection-70"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MemoryFrequency"><span class="tocnumber">4.2.2</span> <span class="toctext">MemoryFrequency</span></a></li>
<li class="toclevel-3 tocsection-71"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MemoryBusWidth"><span class="tocnumber">4.2.3</span> <span class="toctext">MemoryBusWidth</span></a></li>
<li class="toclevel-3 tocsection-72"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MemoryBuses"><span class="tocnumber">4.2.4</span> <span class="toctext">MemoryBuses</span></a></li>
<li class="toclevel-3 tocsection-73"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SharedBanks"><span class="tocnumber">4.2.5</span> <span class="toctext">SharedBanks</span></a></li>
<li class="toclevel-3 tocsection-74"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BankGranurality"><span class="tocnumber">4.2.6</span> <span class="toctext">BankGranurality</span></a></li>
<li class="toclevel-3 tocsection-75"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ReadLatency"><span class="tocnumber">4.2.7</span> <span class="toctext">ReadLatency</span></a></li>
<li class="toclevel-3 tocsection-76"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#WriteLatency"><span class="tocnumber">4.2.8</span> <span class="toctext">WriteLatency</span></a></li>
<li class="toclevel-3 tocsection-77"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#WriteToReadLatency"><span class="tocnumber">4.2.9</span> <span class="toctext">WriteToReadLatency</span></a></li>
<li class="toclevel-3 tocsection-78"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MemoryPageSize"><span class="tocnumber">4.2.10</span> <span class="toctext">MemoryPageSize</span></a></li>
<li class="toclevel-3 tocsection-79"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#OpenPages"><span class="tocnumber">4.2.11</span> <span class="toctext">OpenPages</span></a></li>
<li class="toclevel-3 tocsection-80"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#PageOpenLatency"><span class="tocnumber">4.2.12</span> <span class="toctext">PageOpenLatency</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-81"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#New_Memory_Controller_parameters_.28aka_MCV2.29"><span class="tocnumber">4.3</span> <span class="toctext">New Memory Controller parameters (aka MCV2)</span></a>
<ul>
<li class="toclevel-3 tocsection-82"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MemoryControllerV2"><span class="tocnumber">4.3.1</span> <span class="toctext">MemoryControllerV2</span></a></li>
<li class="toclevel-3 tocsection-83"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2MemoryChannels"><span class="tocnumber">4.3.2</span> <span class="toctext">V2MemoryChannels</span></a></li>
<li class="toclevel-3 tocsection-84"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2BanksPerMemoryChannel"><span class="tocnumber">4.3.3</span> <span class="toctext">V2BanksPerMemoryChannel</span></a></li>
<li class="toclevel-3 tocsection-85"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2MemoryRowSize"><span class="tocnumber">4.3.4</span> <span class="toctext">V2MemoryRowSize</span></a></li>
<li class="toclevel-3 tocsection-86"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2BurstBytesPerCycle"><span class="tocnumber">4.3.5</span> <span class="toctext">V2BurstBytesPerCycle</span></a></li>
<li class="toclevel-3 tocsection-87"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2SplitterType"><span class="tocnumber">4.3.6</span> <span class="toctext">V2SplitterType</span></a></li>
<li class="toclevel-3 tocsection-88"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2ChannelInterleaving"><span class="tocnumber">4.3.7</span> <span class="toctext">V2ChannelInterleaving</span></a></li>
<li class="toclevel-3 tocsection-89"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2BankInterleaving"><span class="tocnumber">4.3.8</span> <span class="toctext">V2BankInterleaving</span></a></li>
<li class="toclevel-3 tocsection-90"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2ChannelInterleavingMask"><span class="tocnumber">4.3.9</span> <span class="toctext">V2ChannelInterleavingMask</span></a></li>
<li class="toclevel-3 tocsection-91"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2BankInterleavingMask"><span class="tocnumber">4.3.10</span> <span class="toctext">V2BankInterleavingMask</span></a></li>
<li class="toclevel-3 tocsection-92"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2SecondInterleaving"><span class="tocnumber">4.3.11</span> <span class="toctext">V2SecondInterleaving</span></a></li>
<li class="toclevel-3 tocsection-93"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2SecondChannelInterleaving"><span class="tocnumber">4.3.12</span> <span class="toctext">V2SecondChannelInterleaving</span></a></li>
<li class="toclevel-3 tocsection-94"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2SecondBankInterleaving"><span class="tocnumber">4.3.13</span> <span class="toctext">V2SecondBankInterleaving</span></a></li>
<li class="toclevel-3 tocsection-95"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2SecondChannelInterleavingMask"><span class="tocnumber">4.3.14</span> <span class="toctext">V2SecondChannelInterleavingMask</span></a></li>
<li class="toclevel-3 tocsection-96"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2SecondBankInterleavingMask"><span class="tocnumber">4.3.15</span> <span class="toctext">V2SecondBankInterleavingMask</span></a></li>
<li class="toclevel-3 tocsection-97"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2BankSelectionPolicy"><span class="tocnumber">4.3.16</span> <span class="toctext">V2BankSelectionPolicy</span></a></li>
<li class="toclevel-3 tocsection-98"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2ChannelScheduler"><span class="tocnumber">4.3.17</span> <span class="toctext">V2ChannelScheduler</span></a></li>
<li class="toclevel-3 tocsection-99"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2PagePolicy"><span class="tocnumber">4.3.18</span> <span class="toctext">V2PagePolicy</span></a></li>
<li class="toclevel-3 tocsection-100"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2MaxChannelTransactions"><span class="tocnumber">4.3.19</span> <span class="toctext">V2MaxChannelTransactions</span></a></li>
<li class="toclevel-3 tocsection-101"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2MemoryTrace"><span class="tocnumber">4.3.20</span> <span class="toctext">V2MemoryTrace</span></a></li>
<li class="toclevel-3 tocsection-102"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2DisableActiveManager"><span class="tocnumber">4.3.21</span> <span class="toctext">V2DisableActiveManager</span></a></li>
<li class="toclevel-3 tocsection-103"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2DisablePrechargeManager"><span class="tocnumber">4.3.22</span> <span class="toctext">V2DisablePrechargeManager</span></a></li>
<li class="toclevel-3 tocsection-104"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2ManagerSelectionAlgorithm"><span class="tocnumber">4.3.23</span> <span class="toctext">V2ManagerSelectionAlgorithm</span></a></li>
<li class="toclevel-3 tocsection-105"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2MemoryType"><span class="tocnumber">4.3.24</span> <span class="toctext">V2MemoryType</span></a></li>
<li class="toclevel-3 tocsection-106"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2GDDR_Profile"><span class="tocnumber">4.3.25</span> <span class="toctext">V2GDDR_Profile</span></a></li>
<li class="toclevel-3 tocsection-107"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2GDDR_tRRD"><span class="tocnumber">4.3.26</span> <span class="toctext">V2GDDR_tRRD</span></a></li>
<li class="toclevel-3 tocsection-108"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2GDDR_tRCD"><span class="tocnumber">4.3.27</span> <span class="toctext">V2GDDR_tRCD</span></a></li>
<li class="toclevel-3 tocsection-109"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2GDDR_tWTR"><span class="tocnumber">4.3.28</span> <span class="toctext">V2GDDR_tWTR</span></a></li>
<li class="toclevel-3 tocsection-110"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2GDDR_tRTW"><span class="tocnumber">4.3.29</span> <span class="toctext">V2GDDR_tRTW</span></a></li>
<li class="toclevel-3 tocsection-111"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2GDDR_tWR"><span class="tocnumber">4.3.30</span> <span class="toctext">V2GDDR_tWR</span></a></li>
<li class="toclevel-3 tocsection-112"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2GDDR_tRP"><span class="tocnumber">4.3.31</span> <span class="toctext">V2GDDR_tRP</span></a></li>
<li class="toclevel-3 tocsection-113"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2GDDR_CAS"><span class="tocnumber">4.3.32</span> <span class="toctext">V2GDDR_CAS</span></a></li>
<li class="toclevel-3 tocsection-114"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#V2GDDR_WL"><span class="tocnumber">4.3.33</span> <span class="toctext">V2GDDR_WL</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-115"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#STREAMER_section"><span class="tocnumber">5</span> <span class="toctext">STREAMER section</span></a>
<ul>
<li class="toclevel-2 tocsection-116"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Vertex_Cache_and_Streamer_Commit_parameters"><span class="tocnumber">5.1</span> <span class="toctext">Vertex Cache and Streamer Commit parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-117"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#IndicesCycle"><span class="tocnumber">5.1.1</span> <span class="toctext">IndicesCycle</span></a></li>
<li class="toclevel-3 tocsection-118"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#IndexBufferSize"><span class="tocnumber">5.1.2</span> <span class="toctext">IndexBufferSize</span></a></li>
<li class="toclevel-3 tocsection-119"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#OutputFIFOSize"><span class="tocnumber">5.1.3</span> <span class="toctext">OutputFIFOSize</span></a></li>
<li class="toclevel-3 tocsection-120"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#OutputMemorySize"><span class="tocnumber">5.1.4</span> <span class="toctext">OutputMemorySize</span></a></li>
<li class="toclevel-3 tocsection-121"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#VerticesCycle"><span class="tocnumber">5.1.5</span> <span class="toctext">VerticesCycle</span></a></li>
<li class="toclevel-3 tocsection-122"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#AttributesSentCycle"><span class="tocnumber">5.1.6</span> <span class="toctext">AttributesSentCycle</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-123"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Streamer_Loader_parameters"><span class="tocnumber">5.2</span> <span class="toctext">Streamer Loader parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-124"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#StreamerLoaderUnits"><span class="tocnumber">5.2.1</span> <span class="toctext">StreamerLoaderUnits</span></a></li>
<li class="toclevel-3 tocsection-125"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SLIndicesCycle"><span class="tocnumber">5.2.2</span> <span class="toctext">SLIndicesCycle</span></a></li>
<li class="toclevel-3 tocsection-126"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SLInputRequestQueueSize"><span class="tocnumber">5.2.3</span> <span class="toctext">SLInputRequestQueueSize</span></a></li>
<li class="toclevel-3 tocsection-127"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SLAttributesCycle"><span class="tocnumber">5.2.4</span> <span class="toctext">SLAttributesCycle</span></a></li>
<li class="toclevel-3 tocsection-128"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SLInputCacheLines"><span class="tocnumber">5.2.5</span> <span class="toctext">SLInputCacheLines</span></a></li>
<li class="toclevel-3 tocsection-129"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SLInputCacheLineSize"><span class="tocnumber">5.2.6</span> <span class="toctext">SLInputCacheLineSize</span></a></li>
<li class="toclevel-3 tocsection-130"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SLInputCachePortWidth"><span class="tocnumber">5.2.7</span> <span class="toctext">SLInputCachePortWidth</span></a></li>
<li class="toclevel-3 tocsection-131"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SLInputCacheRequestQueueSize"><span class="tocnumber">5.2.8</span> <span class="toctext">SLInputCacheRequestQueueSize</span></a></li>
<li class="toclevel-3 tocsection-132"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SLInputCacheInputQueueSize"><span class="tocnumber">5.2.9</span> <span class="toctext">SLInputCacheInputQueueSize</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-133"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#VERTEXSHADER_section"><span class="tocnumber">6</span> <span class="toctext">VERTEXSHADER section</span></a>
<ul>
<li class="toclevel-2 tocsection-134"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ExecutableThreads_.28VSH.29"><span class="tocnumber">6.1</span> <span class="toctext">ExecutableThreads (VSH)</span></a></li>
<li class="toclevel-2 tocsection-135"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#InputBuffers_.28VSH.29"><span class="tocnumber">6.2</span> <span class="toctext">InputBuffers (VSH)</span></a></li>
<li class="toclevel-2 tocsection-136"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ThreadResources_.28VSH.29"><span class="tocnumber">6.3</span> <span class="toctext">ThreadResources (VSH)</span></a></li>
<li class="toclevel-2 tocsection-137"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ThreadRate_.28VSH.29"><span class="tocnumber">6.4</span> <span class="toctext">ThreadRate (VSH)</span></a></li>
<li class="toclevel-2 tocsection-138"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#FetchRate_.28VSH.29"><span class="tocnumber">6.5</span> <span class="toctext">FetchRate (VSH)</span></a></li>
<li class="toclevel-2 tocsection-139"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ThreadGroup_.28VSH.29"><span class="tocnumber">6.6</span> <span class="toctext">ThreadGroup (VSH)</span></a></li>
<li class="toclevel-2 tocsection-140"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#LockedExecutionMode_.28VSH.29"><span class="tocnumber">6.7</span> <span class="toctext">LockedExecutionMode (VSH)</span></a></li>
<li class="toclevel-2 tocsection-141"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ScalarALU_.28VSH.29"><span class="tocnumber">6.8</span> <span class="toctext">ScalarALU (VSH)</span></a></li>
<li class="toclevel-2 tocsection-142"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ThreadWindow_.28VSH.29"><span class="tocnumber">6.9</span> <span class="toctext">ThreadWindow (VSH)</span></a></li>
<li class="toclevel-2 tocsection-143"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#FetchDelay_.28VSH.29"><span class="tocnumber">6.10</span> <span class="toctext">FetchDelay (VSH)</span></a></li>
<li class="toclevel-2 tocsection-144"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SwapOnBlock_.28VSH.29"><span class="tocnumber">6.11</span> <span class="toctext">SwapOnBlock (VSH)</span></a></li>
<li class="toclevel-2 tocsection-145"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#InputsPerCycle_.28VSH.29"><span class="tocnumber">6.12</span> <span class="toctext">InputsPerCycle (VSH)</span></a></li>
<li class="toclevel-2 tocsection-146"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#OutputsPerCycle_.28VSH.29"><span class="tocnumber">6.13</span> <span class="toctext">OutputsPerCycle (VSH)</span></a></li>
<li class="toclevel-2 tocsection-147"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#OutputLatency_.28VSH.29"><span class="tocnumber">6.14</span> <span class="toctext">OutputLatency (VSH)</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-148"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#PRIMITIVEASSEMBLY_section"><span class="tocnumber">7</span> <span class="toctext">PRIMITIVEASSEMBLY section</span></a>
<ul>
<li class="toclevel-2 tocsection-149"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#VerticesCycle_2"><span class="tocnumber">7.1</span> <span class="toctext">VerticesCycle</span></a></li>
<li class="toclevel-2 tocsection-150"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TrianglesCycle"><span class="tocnumber">7.2</span> <span class="toctext">TrianglesCycle</span></a></li>
<li class="toclevel-2 tocsection-151"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#InputBusLatency"><span class="tocnumber">7.3</span> <span class="toctext">InputBusLatency</span></a></li>
<li class="toclevel-2 tocsection-152"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#AssemblyQueueSize"><span class="tocnumber">7.4</span> <span class="toctext">AssemblyQueueSize</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-153"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#CLIPPER_section"><span class="tocnumber">8</span> <span class="toctext">CLIPPER section</span></a>
<ul>
<li class="toclevel-2 tocsection-154"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TrianglesCycle_2"><span class="tocnumber">8.1</span> <span class="toctext">TrianglesCycle</span></a></li>
<li class="toclevel-2 tocsection-155"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ClipperUnits"><span class="tocnumber">8.2</span> <span class="toctext">ClipperUnits</span></a></li>
<li class="toclevel-2 tocsection-156"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#StartLatency"><span class="tocnumber">8.3</span> <span class="toctext">StartLatency</span></a></li>
<li class="toclevel-2 tocsection-157"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ExecLatency"><span class="tocnumber">8.4</span> <span class="toctext">ExecLatency</span></a></li>
<li class="toclevel-2 tocsection-158"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ClipBufferSize"><span class="tocnumber">8.5</span> <span class="toctext">ClipBufferSize</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-159"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#RASTERIZER_Section"><span class="tocnumber">9</span> <span class="toctext">RASTERIZER Section</span></a>
<ul>
<li class="toclevel-2 tocsection-160"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Triangle_Setup_parameters"><span class="tocnumber">9.1</span> <span class="toctext">Triangle Setup parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-161"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TrianglesCycle_3"><span class="tocnumber">9.1.1</span> <span class="toctext">TrianglesCycle</span></a></li>
<li class="toclevel-3 tocsection-162"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SetupFIFOSize"><span class="tocnumber">9.1.2</span> <span class="toctext">SetupFIFOSize</span></a></li>
<li class="toclevel-3 tocsection-163"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SetupUnits"><span class="tocnumber">9.1.3</span> <span class="toctext">SetupUnits</span></a></li>
<li class="toclevel-3 tocsection-164"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SetupLatency"><span class="tocnumber">9.1.4</span> <span class="toctext">SetupLatency</span></a></li>
<li class="toclevel-3 tocsection-165"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SetupStartLatency"><span class="tocnumber">9.1.5</span> <span class="toctext">SetupStartLatency</span></a></li>
<li class="toclevel-3 tocsection-166"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TriangleInputLatency"><span class="tocnumber">9.1.6</span> <span class="toctext">TriangleInputLatency</span></a></li>
<li class="toclevel-3 tocsection-167"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TriangleOutputLatency"><span class="tocnumber">9.1.7</span> <span class="toctext">TriangleOutputLatency</span></a></li>
<li class="toclevel-3 tocsection-168"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TriangleSetupOnShader"><span class="tocnumber">9.1.8</span> <span class="toctext">TriangleSetupOnShader</span></a></li>
<li class="toclevel-3 tocsection-169"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TriangleShaderQueueSize"><span class="tocnumber">9.1.9</span> <span class="toctext">TriangleShaderQueueSize</span></a></li>
<li class="toclevel-3 tocsection-170"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#EmulatorStoredTriangles"><span class="tocnumber">9.1.10</span> <span class="toctext">EmulatorStoredTriangles</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-171"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Rasterization_parameters"><span class="tocnumber">9.2</span> <span class="toctext">Rasterization parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-172"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#StampsPerCycle"><span class="tocnumber">9.2.1</span> <span class="toctext">StampsPerCycle</span></a></li>
<li class="toclevel-3 tocsection-173"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MSAASamplesCycle"><span class="tocnumber">9.2.2</span> <span class="toctext">MSAASamplesCycle</span></a></li>
<li class="toclevel-3 tocsection-174"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#OverScanWidth"><span class="tocnumber">9.2.3</span> <span class="toctext">OverScanWidth</span></a></li>
<li class="toclevel-3 tocsection-175"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#OverScanHeight"><span class="tocnumber">9.2.4</span> <span class="toctext">OverScanHeight</span></a></li>
<li class="toclevel-3 tocsection-176"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ScanWidth"><span class="tocnumber">9.2.5</span> <span class="toctext">ScanWidth</span></a></li>
<li class="toclevel-3 tocsection-177"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ScanHeight"><span class="tocnumber">9.2.6</span> <span class="toctext">ScanHeight</span></a></li>
<li class="toclevel-3 tocsection-178"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#GenWidth"><span class="tocnumber">9.2.7</span> <span class="toctext">GenWidth</span></a></li>
<li class="toclevel-3 tocsection-179"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#GenHeight"><span class="tocnumber">9.2.8</span> <span class="toctext">GenHeight</span></a></li>
<li class="toclevel-3 tocsection-180"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#RasterizationBatchSize"><span class="tocnumber">9.2.9</span> <span class="toctext">RasterizationBatchSize</span></a></li>
<li class="toclevel-3 tocsection-181"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BatchQueueSize"><span class="tocnumber">9.2.10</span> <span class="toctext">BatchQueueSize</span></a></li>
<li class="toclevel-3 tocsection-182"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#RecursiveMode"><span class="tocnumber">9.2.11</span> <span class="toctext">RecursiveMode</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-183"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Micropolygon_rasterization_parameters"><span class="tocnumber">9.3</span> <span class="toctext">Micropolygon rasterization parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-184"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#UseMicroPolygonRasterizer"><span class="tocnumber">9.3.1</span> <span class="toctext">UseMicroPolygonRasterizer</span></a></li>
<li class="toclevel-3 tocsection-185"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TriangleBoundOutputLatency"><span class="tocnumber">9.3.2</span> <span class="toctext">TriangleBoundOutputLatency</span></a></li>
<li class="toclevel-3 tocsection-186"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TriangleBoundOpLatency"><span class="tocnumber">9.3.3</span> <span class="toctext">TriangleBoundOpLatency</span></a></li>
<li class="toclevel-3 tocsection-187"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#LargeTriangleFIFOSize"><span class="tocnumber">9.3.4</span> <span class="toctext">LargeTriangleFIFOSize</span></a></li>
<li class="toclevel-3 tocsection-188"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MicroTriangleFIFOSize"><span class="tocnumber">9.3.5</span> <span class="toctext">MicroTriangleFIFOSize</span></a></li>
<li class="toclevel-3 tocsection-189"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BypassStampFIFOSize"><span class="tocnumber">9.3.6</span> <span class="toctext">BypassStampFIFOSize</span></a></li>
<li class="toclevel-3 tocsection-190"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MicroTriangleBypass"><span class="tocnumber">9.3.7</span> <span class="toctext">MicroTriangleBypass</span></a></li>
<li class="toclevel-3 tocsection-191"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BypassMode"><span class="tocnumber">9.3.8</span> <span class="toctext">BypassMode</span></a></li>
<li class="toclevel-3 tocsection-192"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#DumpTriangleBurstSizeHistogram"><span class="tocnumber">9.3.9</span> <span class="toctext">DumpTriangleBurstSizeHistogram</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-193"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Hierarchical_Z_parameters"><span class="tocnumber">9.4</span> <span class="toctext">Hierarchical Z parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-194"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#DisableHZ"><span class="tocnumber">9.4.1</span> <span class="toctext">DisableHZ</span></a></li>
<li class="toclevel-3 tocsection-195"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#StampsPerHZBlock"><span class="tocnumber">9.4.2</span> <span class="toctext">StampsPerHZBlock</span></a></li>
<li class="toclevel-3 tocsection-196"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#HierarchicalZBufferSize"><span class="tocnumber">9.4.3</span> <span class="toctext">HierarchicalZBufferSize</span></a></li>
<li class="toclevel-3 tocsection-197"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#HZCacheLines"><span class="tocnumber">9.4.4</span> <span class="toctext">HZCacheLines</span></a></li>
<li class="toclevel-3 tocsection-198"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#HZCacheLineSize"><span class="tocnumber">9.4.5</span> <span class="toctext">HZCacheLineSize</span></a></li>
<li class="toclevel-3 tocsection-199"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#EarlyZQueueSize"><span class="tocnumber">9.4.6</span> <span class="toctext">EarlyZQueueSize</span></a></li>
<li class="toclevel-3 tocsection-200"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#HZAccessLatency"><span class="tocnumber">9.4.7</span> <span class="toctext">HZAccessLatency</span></a></li>
<li class="toclevel-3 tocsection-201"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#HZUpdateLatency"><span class="tocnumber">9.4.8</span> <span class="toctext">HZUpdateLatency</span></a></li>
<li class="toclevel-3 tocsection-202"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#HZBlocksClearedPerCycle"><span class="tocnumber">9.4.9</span> <span class="toctext">HZBlocksClearedPerCycle</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-203"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Interpolator_parameters"><span class="tocnumber">9.5</span> <span class="toctext">Interpolator parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-204"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#NumInterpolators"><span class="tocnumber">9.5.1</span> <span class="toctext">NumInterpolators</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-205"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Work_Distributor_.28FragmentFIFO.29_parameters"><span class="tocnumber">9.6</span> <span class="toctext">Work Distributor (FragmentFIFO) parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-206"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ShaderInputQueueSize"><span class="tocnumber">9.6.1</span> <span class="toctext">ShaderInputQueueSize</span></a></li>
<li class="toclevel-3 tocsection-207"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ShaderOutputQueueSize"><span class="tocnumber">9.6.2</span> <span class="toctext">ShaderOutputQueueSize</span></a></li>
<li class="toclevel-3 tocsection-208"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ShaderInputBatchSize"><span class="tocnumber">9.6.3</span> <span class="toctext">ShaderInputBatchSize</span></a></li>
<li class="toclevel-3 tocsection-209"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TiledShaderDistribution"><span class="tocnumber">9.6.4</span> <span class="toctext">TiledShaderDistribution</span></a></li>
<li class="toclevel-3 tocsection-210"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#VertexInputQueueSize"><span class="tocnumber">9.6.5</span> <span class="toctext">VertexInputQueueSize</span></a></li>
<li class="toclevel-3 tocsection-211"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ShadedVertexQueueSize"><span class="tocnumber">9.6.6</span> <span class="toctext">ShadedVertexQueueSize</span></a></li>
<li class="toclevel-3 tocsection-212"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TriangleInputQueueSize"><span class="tocnumber">9.6.7</span> <span class="toctext">TriangleInputQueueSize</span></a></li>
<li class="toclevel-3 tocsection-213"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TriangleOutputQueueSize"><span class="tocnumber">9.6.8</span> <span class="toctext">TriangleOutputQueueSize</span></a></li>
<li class="toclevel-3 tocsection-214"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#GeneratedStampQueueSize"><span class="tocnumber">9.6.9</span> <span class="toctext">GeneratedStampQueueSize</span></a></li>
<li class="toclevel-3 tocsection-215"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#EarlyZTestedStampQueueSize"><span class="tocnumber">9.6.10</span> <span class="toctext">EarlyZTestedStampQueueSize</span></a></li>
<li class="toclevel-3 tocsection-216"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#InterpolatedStampQueueSize"><span class="tocnumber">9.6.11</span> <span class="toctext">InterpolatedStampQueueSize</span></a></li>
<li class="toclevel-3 tocsection-217"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ShadedStampQueueSize"><span class="tocnumber">9.6.12</span> <span class="toctext">ShadedStampQueueSize</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-218"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#FRAGMENTSHADER_section"><span class="tocnumber">10</span> <span class="toctext">FRAGMENTSHADER section</span></a>
<ul>
<li class="toclevel-2 tocsection-219"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Common_Shader_parameters"><span class="tocnumber">10.1</span> <span class="toctext">Common Shader parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-220"><a href="./ATTILA Configuration File Public - AttilaWiki_files/ATTILA Configuration File Public - AttilaWiki.htm"><span class="tocnumber">10.1.1</span> <span class="toctext">VertexAttributeLoadFromShader</span></a></li>
<li class="toclevel-3 tocsection-221"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SwapOnBlock"><span class="tocnumber">10.1.2</span> <span class="toctext">SwapOnBlock</span></a></li>
<li class="toclevel-3 tocsection-222"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#FixedLatencyALU"><span class="tocnumber">10.1.3</span> <span class="toctext">FixedLatencyALU</span></a></li>
<li class="toclevel-3 tocsection-223"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#InputsPerCycle"><span class="tocnumber">10.1.4</span> <span class="toctext">InputsPerCycle</span></a></li>
<li class="toclevel-3 tocsection-224"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#OutputsPerCycle"><span class="tocnumber">10.1.5</span> <span class="toctext">OutputsPerCycle</span></a></li>
<li class="toclevel-3 tocsection-225"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#OutputLatency"><span class="tocnumber">10.1.6</span> <span class="toctext">OutputLatency</span></a></li>
<li class="toclevel-3 tocsection-226"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureUnits"><span class="tocnumber">10.1.7</span> <span class="toctext">TextureUnits</span></a></li>
<li class="toclevel-3 tocsection-227"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureRequestRate"><span class="tocnumber">10.1.8</span> <span class="toctext">TextureRequestRate</span></a></li>
<li class="toclevel-3 tocsection-228"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureRequestGroup"><span class="tocnumber">10.1.9</span> <span class="toctext">TextureRequestGroup</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-229"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Legacy_Shader_parameters"><span class="tocnumber">10.2</span> <span class="toctext">Legacy Shader parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-230"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ExecutableThreads"><span class="tocnumber">10.2.1</span> <span class="toctext">ExecutableThreads</span></a></li>
<li class="toclevel-3 tocsection-231"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#InputBuffers"><span class="tocnumber">10.2.2</span> <span class="toctext">InputBuffers</span></a></li>
<li class="toclevel-3 tocsection-232"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ThreadResources"><span class="tocnumber">10.2.3</span> <span class="toctext">ThreadResources</span></a></li>
<li class="toclevel-3 tocsection-233"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ThreadRate"><span class="tocnumber">10.2.4</span> <span class="toctext">ThreadRate</span></a></li>
<li class="toclevel-3 tocsection-234"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ThreadWindow"><span class="tocnumber">10.2.5</span> <span class="toctext">ThreadWindow</span></a></li>
<li class="toclevel-3 tocsection-235"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#FetchDelay"><span class="tocnumber">10.2.6</span> <span class="toctext">FetchDelay</span></a></li>
<li class="toclevel-3 tocsection-236"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#FetchRate"><span class="tocnumber">10.2.7</span> <span class="toctext">FetchRate</span></a></li>
<li class="toclevel-3 tocsection-237"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ScalarALU"><span class="tocnumber">10.2.8</span> <span class="toctext">ScalarALU</span></a></li>
<li class="toclevel-3 tocsection-238"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ThreadGroup"><span class="tocnumber">10.2.9</span> <span class="toctext">ThreadGroup</span></a></li>
<li class="toclevel-3 tocsection-239"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#LockedExecutionMode"><span class="tocnumber">10.2.10</span> <span class="toctext">LockedExecutionMode</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-240"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Vector_Shader_parameters"><span class="tocnumber">10.3</span> <span class="toctext">Vector Shader parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-241"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#VectorShader"><span class="tocnumber">10.3.1</span> <span class="toctext">VectorShader</span></a></li>
<li class="toclevel-3 tocsection-242"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#VectorThreads"><span class="tocnumber">10.3.2</span> <span class="toctext">VectorThreads</span></a></li>
<li class="toclevel-3 tocsection-243"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#VectorResources"><span class="tocnumber">10.3.3</span> <span class="toctext">VectorResources</span></a></li>
<li class="toclevel-3 tocsection-244"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#VectorLength"><span class="tocnumber">10.3.4</span> <span class="toctext">VectorLength</span></a></li>
<li class="toclevel-3 tocsection-245"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#VectorALUWidth"><span class="tocnumber">10.3.5</span> <span class="toctext">VectorALUWidth</span></a></li>
<li class="toclevel-3 tocsection-246"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#VectorALUConfig"><span class="tocnumber">10.3.6</span> <span class="toctext">VectorALUConfig</span></a></li>
<li class="toclevel-3 tocsection-247"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#VectorWaitOnStall"><span class="tocnumber">10.3.7</span> <span class="toctext">VectorWaitOnStall</span></a></li>
<li class="toclevel-3 tocsection-248"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#VectorExplicitBlock"><span class="tocnumber">10.3.8</span> <span class="toctext">VectorExplicitBlock</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-249"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Texture_Unit_parameters"><span class="tocnumber">10.4</span> <span class="toctext">Texture Unit parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-250"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#AddressALULatency"><span class="tocnumber">10.4.1</span> <span class="toctext">AddressALULatency</span></a></li>
<li class="toclevel-3 tocsection-251"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#FilterALULatency"><span class="tocnumber">10.4.2</span> <span class="toctext">FilterALULatency</span></a></li>
<li class="toclevel-3 tocsection-252"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#AnisotropyAlgorithm"><span class="tocnumber">10.4.3</span> <span class="toctext">AnisotropyAlgorithm</span></a></li>
<li class="toclevel-3 tocsection-253"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ForceMaxAnisotropy"><span class="tocnumber">10.4.4</span> <span class="toctext">ForceMaxAnisotropy</span></a></li>
<li class="toclevel-3 tocsection-254"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#MaxAnisotropy"><span class="tocnumber">10.4.5</span> <span class="toctext">MaxAnisotropy</span></a></li>
<li class="toclevel-3 tocsection-255"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TrilinearPrecision"><span class="tocnumber">10.4.6</span> <span class="toctext">TrilinearPrecision</span></a></li>
<li class="toclevel-3 tocsection-256"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BrilinearThreshold"><span class="tocnumber">10.4.7</span> <span class="toctext">BrilinearThreshold</span></a></li>
<li class="toclevel-3 tocsection-257"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#AnisoRoundPrecision"><span class="tocnumber">10.4.8</span> <span class="toctext">AnisoRoundPrecision</span></a></li>
<li class="toclevel-3 tocsection-258"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#AnisoRoundThreshold"><span class="tocnumber">10.4.9</span> <span class="toctext">AnisoRoundThreshold</span></a></li>
<li class="toclevel-3 tocsection-259"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#AnisoRatioMultOfTwo"><span class="tocnumber">10.4.10</span> <span class="toctext">AnisoRatioMultOfTwo</span></a></li>
<li class="toclevel-3 tocsection-260"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureBlockDimension"><span class="tocnumber">10.4.11</span> <span class="toctext">TextureBlockDimension</span></a></li>
<li class="toclevel-3 tocsection-261"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureSuperBlockDimension"><span class="tocnumber">10.4.12</span> <span class="toctext">TextureSuperBlockDimension</span></a></li>
<li class="toclevel-3 tocsection-262"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureRequestQueueSize"><span class="tocnumber">10.4.13</span> <span class="toctext">TextureRequestQueueSize</span></a></li>
<li class="toclevel-3 tocsection-263"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureAccessQueue"><span class="tocnumber">10.4.14</span> <span class="toctext">TextureAccessQueue</span></a></li>
<li class="toclevel-3 tocsection-264"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureResultQueue"><span class="tocnumber">10.4.15</span> <span class="toctext">TextureResultQueue</span></a></li>
<li class="toclevel-3 tocsection-265"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureWaitReadWindow"><span class="tocnumber">10.4.16</span> <span class="toctext">TextureWaitReadWindow</span></a></li>
<li class="toclevel-3 tocsection-266"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TwoLevelTextureCache"><span class="tocnumber">10.4.17</span> <span class="toctext">TwoLevelTextureCache</span></a></li>
<li class="toclevel-3 tocsection-267"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureCacheLineSize"><span class="tocnumber">10.4.18</span> <span class="toctext">TextureCacheLineSize</span></a></li>
<li class="toclevel-3 tocsection-268"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureCacheWays"><span class="tocnumber">10.4.19</span> <span class="toctext">TextureCacheWays</span></a></li>
<li class="toclevel-3 tocsection-269"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureCacheLines"><span class="tocnumber">10.4.20</span> <span class="toctext">TextureCacheLines</span></a></li>
<li class="toclevel-3 tocsection-270"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureCachePortWidth"><span class="tocnumber">10.4.21</span> <span class="toctext">TextureCachePortWidth</span></a></li>
<li class="toclevel-3 tocsection-271"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureCacheRequestQueueSize"><span class="tocnumber">10.4.22</span> <span class="toctext">TextureCacheRequestQueueSize</span></a></li>
<li class="toclevel-3 tocsection-272"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureCacheInputQueue"><span class="tocnumber">10.4.23</span> <span class="toctext">TextureCacheInputQueue</span></a></li>
<li class="toclevel-3 tocsection-273"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureCacheMissesPerCycle"><span class="tocnumber">10.4.24</span> <span class="toctext">TextureCacheMissesPerCycle</span></a></li>
<li class="toclevel-3 tocsection-274"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureCacheDecompressLatency"><span class="tocnumber">10.4.25</span> <span class="toctext">TextureCacheDecompressLatency</span></a></li>
<li class="toclevel-3 tocsection-275"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureCacheLineSizeL1"><span class="tocnumber">10.4.26</span> <span class="toctext">TextureCacheLineSizeL1</span></a></li>
<li class="toclevel-3 tocsection-276"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureCacheWaysL1"><span class="tocnumber">10.4.27</span> <span class="toctext">TextureCacheWaysL1</span></a></li>
<li class="toclevel-3 tocsection-277"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureCacheLinesL1"><span class="tocnumber">10.4.28</span> <span class="toctext">TextureCacheLinesL1</span></a></li>
<li class="toclevel-3 tocsection-278"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#TextureCacheInputQueueL1"><span class="tocnumber">10.4.29</span> <span class="toctext">TextureCacheInputQueueL1</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-279"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ZSTENCILTEST_section"><span class="tocnumber">11</span> <span class="toctext">ZSTENCILTEST section</span></a>
<ul>
<li class="toclevel-2 tocsection-280"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ROPZ_parameters"><span class="tocnumber">11.1</span> <span class="toctext">ROPZ parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-281"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#StampsPerCycle_.28ROPZ.29"><span class="tocnumber">11.1.1</span> <span class="toctext">StampsPerCycle (ROPZ)</span></a></li>
<li class="toclevel-3 tocsection-282"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BytesPerPixel_.28ROPZ.29"><span class="tocnumber">11.1.2</span> <span class="toctext">BytesPerPixel (ROPZ)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-283"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Z_Cache_parameters"><span class="tocnumber">11.2</span> <span class="toctext">Z Cache parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-284"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ZCacheWays"><span class="tocnumber">11.2.1</span> <span class="toctext">ZCacheWays</span></a></li>
<li class="toclevel-3 tocsection-285"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ZCacheLines"><span class="tocnumber">11.2.2</span> <span class="toctext">ZCacheLines</span></a></li>
<li class="toclevel-3 tocsection-286"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ZCacheStampsPerLine"><span class="tocnumber">11.2.3</span> <span class="toctext">ZCacheStampsPerLine</span></a></li>
<li class="toclevel-3 tocsection-287"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ZCachePortWidth"><span class="tocnumber">11.2.4</span> <span class="toctext">ZCachePortWidth</span></a></li>
<li class="toclevel-3 tocsection-288"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ZCacheExtraReadPort"><span class="tocnumber">11.2.5</span> <span class="toctext">ZCacheExtraReadPort</span></a></li>
<li class="toclevel-3 tocsection-289"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ZCacheExtraWritePort"><span class="tocnumber">11.2.6</span> <span class="toctext">ZCacheExtraWritePort</span></a></li>
<li class="toclevel-3 tocsection-290"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ZCacheRequestQueueSize"><span class="tocnumber">11.2.7</span> <span class="toctext">ZCacheRequestQueueSize</span></a></li>
<li class="toclevel-3 tocsection-291"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ZCacheInputQueueSize"><span class="tocnumber">11.2.8</span> <span class="toctext">ZCacheInputQueueSize</span></a></li>
<li class="toclevel-3 tocsection-292"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ZCacheOutputQueueSize"><span class="tocnumber">11.2.9</span> <span class="toctext">ZCacheOutputQueueSize</span></a></li>
<li class="toclevel-3 tocsection-293"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BlockStateMemorySize_.28ROPZ.29"><span class="tocnumber">11.2.10</span> <span class="toctext">BlockStateMemorySize (ROPZ)</span></a></li>
<li class="toclevel-3 tocsection-294"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BlocksClearedPerCycle_.28ROPZ.29"><span class="tocnumber">11.2.11</span> <span class="toctext">BlocksClearedPerCycle (ROPZ)</span></a></li>
<li class="toclevel-3 tocsection-295"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#DisableCompression_.28ROPZ.29"><span class="tocnumber">11.2.12</span> <span class="toctext">DisableCompression (ROPZ)</span></a></li>
<li class="toclevel-3 tocsection-296"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#CompressionAlgorithm_.28ROPZ.29"><span class="tocnumber">11.2.13</span> <span class="toctext">CompressionAlgorithm (ROPZ)</span></a></li>
<li class="toclevel-3 tocsection-297"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#CompressionUnitLatency_.28ROPZ.29"><span class="tocnumber">11.2.14</span> <span class="toctext">CompressionUnitLatency (ROPZ)</span></a></li>
<li class="toclevel-3 tocsection-298"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#DecompressionUnitLatency_.28ROPZ.29"><span class="tocnumber">11.2.15</span> <span class="toctext">DecompressionUnitLatency (ROPZ)</span></a></li>
<li class="toclevel-3 tocsection-299"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#InputQueueSize_.28ROPZ.29"><span class="tocnumber">11.2.16</span> <span class="toctext">InputQueueSize (ROPZ)</span></a></li>
<li class="toclevel-3 tocsection-300"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#FetchQueueSize_.28ROPZ.29"><span class="tocnumber">11.2.17</span> <span class="toctext">FetchQueueSize (ROPZ)</span></a></li>
<li class="toclevel-3 tocsection-301"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ReadQueueSize_.28ROPZ.29"><span class="tocnumber">11.2.18</span> <span class="toctext">ReadQueueSize (ROPZ)</span></a></li>
<li class="toclevel-3 tocsection-302"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#OpQueueSize_.28ROPZ.29"><span class="tocnumber">11.2.19</span> <span class="toctext">OpQueueSize (ROPZ)</span></a></li>
<li class="toclevel-3 tocsection-303"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#WriteQueueSize"><span class="tocnumber">11.2.20</span> <span class="toctext">WriteQueueSize</span></a></li>
<li class="toclevel-3 tocsection-304"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ZALUTestRate"><span class="tocnumber">11.2.21</span> <span class="toctext">ZALUTestRate</span></a></li>
<li class="toclevel-3 tocsection-305"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ZALULatency"><span class="tocnumber">11.2.22</span> <span class="toctext">ZALULatency</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-306"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#COLORWRITE_section"><span class="tocnumber">12</span> <span class="toctext">COLORWRITE section</span></a>
<ul>
<li class="toclevel-2 tocsection-307"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ROPC_parameters"><span class="tocnumber">12.1</span> <span class="toctext">ROPC parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-308"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#StampsPerCycle_.28ROPC.29"><span class="tocnumber">12.1.1</span> <span class="toctext">StampsPerCycle (ROPC)</span></a></li>
<li class="toclevel-3 tocsection-309"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BytesPerPixel_.28ROPC.29"><span class="tocnumber">12.1.2</span> <span class="toctext">BytesPerPixel (ROPC)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-310"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#Color_Cache_parameters"><span class="tocnumber">12.2</span> <span class="toctext">Color Cache parameters</span></a>
<ul>
<li class="toclevel-3 tocsection-311"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ColorCacheWays"><span class="tocnumber">12.2.1</span> <span class="toctext">ColorCacheWays</span></a></li>
<li class="toclevel-3 tocsection-312"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ColorCacheLines"><span class="tocnumber">12.2.2</span> <span class="toctext">ColorCacheLines</span></a></li>
<li class="toclevel-3 tocsection-313"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ColorCacheStampsPerLine"><span class="tocnumber">12.2.3</span> <span class="toctext">ColorCacheStampsPerLine</span></a></li>
<li class="toclevel-3 tocsection-314"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ColorCachePortWidth"><span class="tocnumber">12.2.4</span> <span class="toctext">ColorCachePortWidth</span></a></li>
<li class="toclevel-3 tocsection-315"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ColorCacheExtraReadPort"><span class="tocnumber">12.2.5</span> <span class="toctext">ColorCacheExtraReadPort</span></a></li>
<li class="toclevel-3 tocsection-316"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ColorCacheExtraWritePort"><span class="tocnumber">12.2.6</span> <span class="toctext">ColorCacheExtraWritePort</span></a></li>
<li class="toclevel-3 tocsection-317"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ColorCacheRequestQueueSize"><span class="tocnumber">12.2.7</span> <span class="toctext">ColorCacheRequestQueueSize</span></a></li>
<li class="toclevel-3 tocsection-318"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ColorCacheInputQueueSize"><span class="tocnumber">12.2.8</span> <span class="toctext">ColorCacheInputQueueSize</span></a></li>
<li class="toclevel-3 tocsection-319"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ColorCacheOutputQueueSize"><span class="tocnumber">12.2.9</span> <span class="toctext">ColorCacheOutputQueueSize</span></a></li>
<li class="toclevel-3 tocsection-320"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BlockStateMemorySize_.28ROPC.29"><span class="tocnumber">12.2.10</span> <span class="toctext">BlockStateMemorySize (ROPC)</span></a></li>
<li class="toclevel-3 tocsection-321"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BlocksClearedPerCycle_.28ROPC.29"><span class="tocnumber">12.2.11</span> <span class="toctext">BlocksClearedPerCycle (ROPC)</span></a></li>
<li class="toclevel-3 tocsection-322"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#DisableCompression_.28ROPC.29"><span class="tocnumber">12.2.12</span> <span class="toctext">DisableCompression (ROPC)</span></a></li>
<li class="toclevel-3 tocsection-323"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#CompressionAlgorithm_.28ROPC.29"><span class="tocnumber">12.2.13</span> <span class="toctext">CompressionAlgorithm (ROPC)</span></a></li>
<li class="toclevel-3 tocsection-324"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#CompressionUnitLatency_.28ROPC.29"><span class="tocnumber">12.2.14</span> <span class="toctext">CompressionUnitLatency (ROPC)</span></a></li>
<li class="toclevel-3 tocsection-325"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#DecompressionUnitLatency"><span class="tocnumber">12.2.15</span> <span class="toctext">DecompressionUnitLatency</span></a></li>
<li class="toclevel-3 tocsection-326"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#InputQueueSize_.28ROPC.29"><span class="tocnumber">12.2.16</span> <span class="toctext">InputQueueSize (ROPC)</span></a></li>
<li class="toclevel-3 tocsection-327"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#FetchQueueSize_.28ROPC.29"><span class="tocnumber">12.2.17</span> <span class="toctext">FetchQueueSize (ROPC)</span></a></li>
<li class="toclevel-3 tocsection-328"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#ReadQueueSize_.28ROPC.29"><span class="tocnumber">12.2.18</span> <span class="toctext">ReadQueueSize (ROPC)</span></a></li>
<li class="toclevel-3 tocsection-329"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#OpQueueSize_.28ROPC.29"><span class="tocnumber">12.2.19</span> <span class="toctext">OpQueueSize (ROPC)</span></a></li>
<li class="toclevel-3 tocsection-330"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#WriteQueueSize_.28ROPC.29"><span class="tocnumber">12.2.20</span> <span class="toctext">WriteQueueSize (ROPC)</span></a></li>
<li class="toclevel-3 tocsection-331"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BlendALUTestRate"><span class="tocnumber">12.2.21</span> <span class="toctext">BlendALUTestRate</span></a></li>
<li class="toclevel-3 tocsection-332"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BlendALULatency"><span class="tocnumber">12.2.22</span> <span class="toctext">BlendALULatency</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-333"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#DAC_section"><span class="tocnumber">13</span> <span class="toctext">DAC section</span></a>
<ul>
<li class="toclevel-2 tocsection-334"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BytesPerPixel_.28DAC.29"><span class="tocnumber">13.1</span> <span class="toctext">BytesPerPixel (DAC)</span></a></li>
<li class="toclevel-2 tocsection-335"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BlockSize"><span class="tocnumber">13.2</span> <span class="toctext">BlockSize</span></a></li>
<li class="toclevel-2 tocsection-336"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BlockUpdateLatency"><span class="tocnumber">13.3</span> <span class="toctext">BlockUpdateLatency</span></a></li>
<li class="toclevel-2 tocsection-337"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BlocksUpdatedPerCycle"><span class="tocnumber">13.4</span> <span class="toctext">BlocksUpdatedPerCycle</span></a></li>
<li class="toclevel-2 tocsection-338"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#BlockRequestQueueSize"><span class="tocnumber">13.5</span> <span class="toctext">BlockRequestQueueSize</span></a></li>
<li class="toclevel-2 tocsection-339"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#DecompressionUnitLatency_2"><span class="tocnumber">13.6</span> <span class="toctext">DecompressionUnitLatency</span></a></li>
<li class="toclevel-2 tocsection-340"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#RefreshRate"><span class="tocnumber">13.7</span> <span class="toctext">RefreshRate</span></a></li>
<li class="toclevel-2 tocsection-341"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SynchedRefresh"><span class="tocnumber">13.8</span> <span class="toctext">SynchedRefresh</span></a></li>
<li class="toclevel-2 tocsection-342"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#RefreshFrame"><span class="tocnumber">13.9</span> <span class="toctext">RefreshFrame</span></a></li>
<li class="toclevel-2 tocsection-343"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#SaveBlitSourceData"><span class="tocnumber">13.10</span> <span class="toctext">SaveBlitSourceData</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table><script>if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<h1> <span class="mw-headline" id="SIMULATOR_section"> SIMULATOR section </span></h1>
<h2> <span class="mw-headline" id="Trace_Parameters"> Trace Parameters </span></h2>
<h3> <span class="mw-headline" id="InputFile"> InputFile </span></h3>
<p><b>Description</b>
</p><p>Name of the OGL (GLInterceptor, only API call trace file) or D3D9 PIX trace file to simulate.
The parameter can be overriden by passing the trace file name as an argument to the simulator binary.
</p><p><b>Format</b>
</p><p>String
</p><p><br>
</p>
<h3> <span class="mw-headline" id="SimCycles"> SimCycles </span></h3>
<p><b>Description</b>
</p><p>Number of cycles to simulate.
When multiple clock domains are supported the GPU or main clock domain is used.
The parameter can be overriden by passing the number of cycles (&gt;10K) or frames (&lt;10K) to simulate as an argument to the simulator binary.
The parameter is overriden by the SimFrames parameter.
</p><p><b>Format</b>
</p><p>Integer
</p><p><br>
</p>
<h3> <span class="mw-headline" id="SimFrames"> SimFrames </span></h3>
<p><b>Description</b>
</p><p>Number of frames to simulate.
This parameter overrides the SimCycles parameter.
The parameter can be overriden by passing the number of cycles (&gt;10K) or frames (&lt;10K) to simulate as an argument to the simulator binary.
</p><p><b>Format</b>
</p><p>Integer
</p><p><br>
</p>
<h3> <span class="mw-headline" id="StartFrame"> StartFrame </span></h3>
<p><b>Description</b>
</p><p>First frame to simulate from the input OGL or D3D9 trace.
The simulator will skip (GPU state and memory state is updated but no rendering will be performed) as many frames as defined by the parameter.
The parameter can be overriden by passing the start frame as an argument to the simulator binary.
</p><p><b>Format</b>
</p><p>Integer
</p>
<h2> <span class="mw-headline" id="Signal_Trace_Parameters"> Signal Trace Parameters </span></h2>
<h3> <span class="mw-headline" id="DumpSignalTrace"> DumpSignalTrace </span></h3>
<p><b>Description</b>
</p><p>Enables dumping a trace of the traffic circulating between boxes through signals.
</p><p><b>Format</b>
</p><p>Boolean (TRUE/FALSE)
</p><p><br>
</p>
<h3> <span class="mw-headline" id="StartSignalDump"> StartSignalDump </span></h3>
<p><b>Description</b>
</p><p>Defines the simulation cycle at which point the dumping of the signal trace will start.
</p><p><b>Format</b>
</p><p>Integer
</p><p><br>
</p>
<h3> <span class="mw-headline" id="SignalDumpCycles"> SignalDumpCycles </span></h3>
<p><b>Description</b>
</p><p>Defines the number of cycles, starting at the defined simulation cycle, for which the signal trace will be dump.
Be aware that the signal trace generates large uncompressed text files and 100K cycles are likely to require more than 1 GB.
</p><p><b>Format</b>
</p><p>Integer
</p><p><br>
</p>
<h3> <span class="mw-headline" id="SignalDumpFile"> SignalDumpFile </span></h3>
<p><b>Description</b>
</p><p>Name of the file that will be generated for the signal trace.
</p><p><b>Format</b>
</p><p>String
</p>
<h2> <span class="mw-headline" id="Statistics_Parameters"> Statistics Parameters </span></h2>
<h3> <span class="mw-headline" id="Statistics"> Statistics </span></h3>
<p><b>Description</b>
</p><p>Enables the generation of GPU statistics.
</p><p><b>Format</b>
</p><p>Boolean (TRUE/FALSE)
</p><p><br>
</p>
<h3> <span class="mw-headline" id="PerCycleStatistics"> PerCycleStatistics </span></h3>
<p><b>Description</b>
</p><p>Enables the generation of GPU statistics sampled at a fixed rate defined in a number of cycles.
The rate is defined by the StatisticsRate parameter.
Statistics generation must be enabled using the Statistics parameter.
</p><p><b>Format</b>
</p><p>Boolean (TRUE/FALSE)
</p><p><br>
</p>
<h3> <span class="mw-headline" id="PerFrameStatistics"> PerFrameStatistics </span></h3>
<p><b>Description</b>
</p><p>Enables the generation of GPU statistics sampled per frame.
Statistics generation must be enabled using the Statistics parameter.
</p><p><b>Format</b>
</p><p>Boolean (TRUE/FALSE)
</p><p><br>
</p>
<h3> <span class="mw-headline" id="PerBatchStatistics"> PerBatchStatistics </span></h3>
<p><b>Description</b>
</p><p>Enables the generation of GPU statistics sampler per drawcall/batch.
Statistics generation must be enabled using the Statistics parameter.
</p><p><b>Format</b>
</p><p>Boolean (TRUE/FALSE)
</p><p><br>
</p>
<h3> <span class="mw-headline" id="StatisticsRate"> StatisticsRate </span></h3>
<p><b>Description</b>
</p><p>Defines the rate, in cycles, at which statistics sampled at a fixed cycle rate will be sampled.
</p><p><b>Format</b>
</p><p>Integer
</p><p><br>
</p>
<h3> <span class="mw-headline" id="StatsFile"> StatsFile </span></h3>
<p><b>Description</b>
</p><p>Name of the file that will be generated for statistics sampled at a fixed cycle rate.
</p><p><b>Format</b>
</p><p>String
</p><p><br>
</p>
<h3> <span class="mw-headline" id="StatsFilePerFrame"> StatsFilePerFrame </span></h3>
<p><b>Description</b>
</p><p>Name of the file that will be generated for statistics sampled per frame.
</p><p><b>Format</b>
</p><p>String
</p><p><br>
</p>
<h3> <span class="mw-headline" id="StatsFilePerBatch"> StatsFilePerBatch </span></h3>
<p><b>Description</b>
</p><p>Name of the file that will be generated for statistics sampled per drawcall/batch.
</p><p><b>Format</b>
</p><p>String
</p>
<h2> <span class="mw-headline" id="Stall_Detection_Parameters"> Stall Detection Parameters </span></h2>
<h3> <span class="mw-headline" id="DetectStalls"> DetectStalls </span></h3>
<p><b>Description</b>
</p><p>Enables the simulator stall detection logic implemented in some of the GPU boxes.
When a the logic detects a stall (no progress) the simulator will stop and generate a stall report (written to StallReport.txt).  The current implementation of the stall detection logic is still a prototype and may detect false stalls.
</p><p><b>Format</b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h2> <span class="mw-headline" id="Fragment_Map_Parameters"> Fragment Map Parameters </span></h2>
<h3> <span class="mw-headline" id="GenerateFragmentMap"> GenerateFragmentMap </span></h3>
<p><b>Description</b>
</p><p>Enables the generation of a fragment map with each frame.
A fragment map stores per quad (2x2 fragment) information in PPM format (3 channel, 8 bits per channel).  Information related with a single fragment will always be for the last fragment written into the corresponding frame position.
</p><p><b>Format</b>
</p><p>Boolean (TRUE/FALSE)
</p><p><br>
</p>
<h3> <span class="mw-headline" id="FragmentMapMode"> FragmentMapMode </span></h3>
<p><b>Description</b>
</p><p>Defines the kind of information that will store the fragment map.
Currently supported values:
</p>
<ul><li> 0&nbsp;: color mode (first fragment in stamp final color)
</li><li> 1&nbsp;: overdraw (number of times fragments were written into the quad)
</li><li> 2&nbsp;: latency of the fragment since it was generated until it was written into the color buffer
</li><li> 3&nbsp;: latency of the fragment inside the shader unit
</li></ul>
<p><b>Format</b>
</p><p>Integer (see above for valid values)
</p>
<h2> <span class="mw-headline" id="API.2FDriver_Parameters"> API/Driver Parameters </span></h2>
<h3> <span class="mw-headline" id="ForceMSAA"> ForceMSAA </span></h3>
<p><b>Description</b>
</p><p>Forces the driver to enable multisampling antialiasing (MSAA).
</p><p><b>Format</b>
</p><p>Boolean (TRUE/FALSE)
</p><p><br>
</p>
<h3> <span class="mw-headline" id="MSAASamples"> MSAASamples </span></h3>
<p><b>Description</b>
</p><p>Defines the number of samples that will be used when the driver forces multisampling antialiasing.
Valid values in the current implementation are: 2, 4 and 8.
</p><p><b>Format</b>
</p><p>Integer (for valid values see above)
</p><p><br>
</p>
<h3> <span class="mw-headline" id="ForceFP16ColorBuffer"> ForceFP16ColorBuffer </span></h3>
<p><b>Description</b>
</p><p>Forces the driver to use a 16-bit float point color buffer.
</p><p><b>Format</b>
</p><p>Boolean (TRUE/FALSE)
</p><p><br>
</p>
<h3> <span class="mw-headline" id="DoubleBuffer"> DoubleBuffer </span></h3>
<p><b>Description</b>
</p><p>Forces the driver to create separated buffers for the front and back color buffers.
</p><p><b>Format</b>
</p><p>Boolean (TRUE/FALSE)
</p><p><br>
</p>
<h3> <span class="mw-headline" id="EnableDriverShaderTranslation"> EnableDriverShaderTranslation </span></h3>
<p><b>Description</b>
</p><p>Enabled shader program translation and transformations by the driver.
Must be enabled to support a number of new features in the Vector Shader model: LDA for attribute load, SOA ALU architecture, wait points.
</p><p><b>Format</b>
</p><p>Boolean (TRUE/FALSE)
</p><p><br>
</p>
<h3> <span class="mw-headline" id="UseACD"> UseACD </span></h3>
<p><b>Description</b>
</p><p>When enabled the OpenGL API implemented using the ACD is used to translate OpenGL traces into Attila commands.
</p><p><b>Format</b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h2> <span class="mw-headline" id="Dynamic_Memory_Parameters"> Dynamic Memory Parameters </span></h2>
<h3> <span class="mw-headline" id="ObjectSize0"> ObjectSize0 </span></h3>
<p><b>Description</b>
</p><p>Defines the size in bytes of allocation blocks in the first bucket of the OptimizedDynamicMemory manager.  The manager can only allocate one block per object so this bucket will be used for objects which size is smaller than the defined size.
</p><p><b>Format</b>
</p><p>Integer
</p><p><br>
</p>
<h3> <span class="mw-headline" id="BucketSize0"> BucketSize0 </span></h3>
<p><b>Description</b>
</p><p>Defines the number of blocks in the first bucket of the OptimizedDynamicMemory manager.
</p><p><b>Format</b>
</p><p>Integer
</p><p><br>
</p>
<h3> <span class="mw-headline" id="ObjectSize1"> ObjectSize1 </span></h3>
<p><b>Description</b>
</p><p>Defines the size in bytes of allocation blocks in the second bucket of the OptimizedDynamicMemory manager.  The size of blocks in the second bucket must be larger than the size of block in the first bucket.  The manager can only allocate one block per object so this bucket will be used for objects which size is larger than the first bucket blocks and smaller than the defined size.
</p><p><b>Format</b>
</p><p>Integer
</p><p><br>
</p>
<h3> <span class="mw-headline" id="BucketSize1"> BucketSize1 </span></h3>
<p><b>Description</b>
</p><p>Defines the number of blocks in the second bucket of the OptimizedDynamicMemory manager.
</p><p><b>Format</b>
</p><p>Integer
</p><p><br>
</p>
<h3> <span class="mw-headline" id="ObjectSize2"> ObjectSize2 </span></h3>
<p><b>Description</b>
</p><p>Defines the size in bytes of allocation blocks in the third bucket of the OptimizedDynamicMemory manager.  The size of blocks in the third bucket must be larger than the size of block in the third bucket.  The manager can only allocate one block per object so this bucket will be used for objects which size is larger than the second bucket blocks and smaller than the defined size.  The third bucket is only available if OptimizedDynamicMemory is compiled with FAST_NEW_DELETE not defined.
</p><p><b>Format</b>
</p><p>Integer
</p><p><br>
</p>
<h3> <span class="mw-headline" id="BucketSize2"> BucketSize2 </span></h3>
<p><b>Description</b>
</p><p>Defines the number of blocks in the third bucket of the OptimizedDynamicMemory manager.
</p><p><b>Format</b>
</p><p>Integer
</p><p><br>
</p>
<h1> <span class="mw-headline" id="GPU_section"> GPU section </span></h1>
<h3> <span class="mw-headline" id="NumVertexShaders"> NumVertexShaders </span></h3>
<p><b>Description</b>
</p><p>For the legacy non-unified shader model the parameter defines the number of vertex shaders implemented in the simulated architecture.
For the unified shader model the parameter defines the number of 'signals' or 'channels' between the Streamer and the Shader Work Distributor (FragmentFIFO) limiting the maximum number of vertices that can start or finish shading in a cycle.  Other parameters may reduce that maximum limit though.
</p><p>Any value is allowed but it has not been tested beyond 8.
The legacy non-unified shader model has not been tested for years.
</p><p><b>Format</b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="NumFragmentShaders"> NumFragmentShaders </span></h3>
<p><b>Description</b>
</p><p>For the legacy non-unified shader model the parameter defines the number of fragment shaders implemented in the simulated architecture.
For the unified shader model the parameter defines the number of shader processors implemented in the simulated architecture.
</p><p>When tiled based fragment distribution is enabled (see RASTERIZATION section) the only values permited for this parameter are 1, 2, 4 and 8.  When 'batch' based distribution is enabled any value should be valid.  The parameter has not been tested with a value larger than 4.
</p><p><b>Format</b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="NumStampPipes"> NumStampPipes </span></h3>
<p><b>Description</b>
</p><p>Defines the number of ROPs in the simulated architecture.  A ROP for Z and Stencil Test (ZSTENCILTEST) is always paired with a ROP for Color Write and Blending (COLORWRITE).
</p><p>Due to how fragment distribution is implemented currently the only allowed values are 1, 2, 4 and 8.  A value of 8 has never been tested.
</p><p><b>Format</b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="GPUClock"> GPUClock </span></h3>
<p><b>Description</b>
</p><p>Frequency in MHz of the GPU clock domain (also called main clock domain).  The GPU clock domain is used for all units except the shader processor and memory (channel schedulers, interface and GDDR) if the frequencies specified for those two are different than the GPU clock frequency.
</p><p>Values up to 1 THz (1M MHz) are allowed as the frequency is internally converted to picoseconds by the simulator.  Due to the conversion to picoseconds the actual simulated frequency (and the ratio with the other clock domain frequencies) may not be exact.
</p><p><b>Format</b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ShaderClock"> ShaderClock </span></h3>
<p><b>Description</b>
</p><p>Defines the frequency of the shader clock domain.  The frequency only applies to the Shader Processor in the unified shader model (excluding interface with Shader Work Distributor/FragmentFIFO and Texture Unit).
</p><p>Shader clock domain is only implemented for the Vector Shader model.
</p><p>Values up to 1 THz (1M MHz) are allowed as the frequency is internally converted to picoseconds by the simulator.  Due to the conversion to picoseconds the actual simulated frequency (and the ratio with the other clock domain frequencies) may not be exact.
</p><p><b>Format</b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="MemoryClock"> MemoryClock </span></h3>
<p><b>Description</b>
</p><p>Defines the frequency of the memory clock domain.  The frequency applies to the channel schedulers, interface and GDDR modules but not to the interconnect network with the different GPU units, request and service queues and the transaction splitter.
</p><p>Values up to 1 THz (1M MHz) are allowed as the frequency is internally converted to picoseconds by the simulator.  Due to the conversion to picoseconds the actual simulated frequency (and the ratio with the other clock domain frequencies) may not be exact.
</p><p><b>Format</b>
</p><p>Integer
</p>
<h1> <span class="mw-headline" id="COMMANDPROCESSOR_section"> COMMANDPROCESSOR section </span></h1>
<h3> <span class="mw-headline" id="PipelinedBatchRendering"> PipelinedBatchRendering </span></h3>
<p><b> Description </b>
</p><p>Enables pipelining the start of draw call with the end of the previous draw call.  Draw call rendering/processing is overlapped if the first draw call has finished all geometry processing (up to Clipper stage) and the second draw call can start.  Updates to the GPU memory from the CPU (AGP_WRITE) are also overlapped if possible to advance work.  Register updates that may affect the previous draw call are stored and applied when the next draw call starts or reached the fragment processing stages.
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="DumpShaderPrograms"> DumpShaderPrograms </span></h3>
<p><b> Description </b>
</p><p>When enabled the Command Processor will dump to files the binary code of the shader programs being loaded.  The files will be named vprogramXXXX.out and fprogramXXXX.out for vertex and fragment programs and XXXX defines the order of the shader programas as it was loaded starting at 0000.  A shader program may not be executed even if it's loaded but the current implementation of the libraries I think links the program load with an actual draw call.
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h1> <span class="mw-headline" id="MEMORYCONTROLLER"> MEMORYCONTROLLER </span></h1>
<h2> <span class="mw-headline" id="Common_parameters"> Common parameters </span></h2>
<h3> <span class="mw-headline" id="MemorySize"> MemorySize </span></h3>
<p><b> Description </b>
</p><p>Defines the size in MBs of the GPU memory.
</p><p>For the MemoryControllerV2 model there may be limitations with this size related with page size (row size), number of channels, banks, etc defined for the model.
</p><p>In the current implementation the GPU address space is limited to 32-bit and only the lower 2 GBs can be used for GPU memory.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="MappedMemorySize"> MappedMemorySize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the CPU (system) memory mapped to the GPU address space.
</p><p>In the current implementation the GPU address space is limited to 32-bit and only the upper 2 GBs can be used for mapped memory.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BurstLength"> BurstLength </span></h3>
<p><b> Description </b>
</p><p>The purpose of the parameter was to define the number of data cycles per burst request to GDDR memory (for GDDR there are 2 data cycles per source/command clock).
</p><p>Passed to legacy Memory Controller but not used.  A constant is used to defined the GDDR data burst.
</p><p>Passed to Memory Controller V2. Use?
</p><p>Valid values for GDDR2 are 4 or 8.  Later GDDR3 and GDDR4 specs only allow 8.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="MaxConsecutiveReads"> MaxConsecutiveReads </span></h3>
<p><b> Description </b>
</p><p>Defines the maximum number of consecutive read requests that are issued to GDDR before forcing to issue write requests (if there is any queued).
</p><p>Applies to both the legacy Memory Controller and V2.  In Memory Controller V2 it may only apply to configurations with a scheduler implementing separated queues for read and write requests.
</p><p>Recommended value for performance is still under discussion.  This includes discussion about implementing a dynamic algorithm in Memory Controller V2.  The usual value we have been using is 16.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="MaxConsecutiveWrites"> MaxConsecutiveWrites </span></h3>
<p><b> Description </b>
</p><p>Defines the maximum number of consecutive write requests that are issued to GDDR before forcing to issue read requests (if there is any queued). 
</p><p>Applies to both the legacy Memory Controller and V2. In Memory Controller V2 it may only apply to configurations with a scheduler implementing separated queues for read and write requests. 
</p><p>Recommended value for performance is still under discussion. This includes discussion about implementing a dynamic algorithm in Memory Controller V2. The usual value we have been using is 16.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="CommandProcessorBusWidth"> CommandProcessorBusWidth </span></h3>
<p><b> Description </b>
</p><p>Defines the bandwidth in bytes per cycle (GPU/main clock) of the connection between the Memory Controller and the Command Processor.
</p><p>The bandwidth defined for this bus actually also limits the bandwidth from system to GPU (AGP or PCIe bus) for data writes or reads (reads from GPU to system are not currently implemented).  In this aspect the Command Processor could be considered to be acting as a simple DMA controller.  For itself the Command Processor only consumes BW when reading shader programs from memory and loading them in the shader instruction memory at the shader processors.
</p><p>Normal values for this parameter are 8 or 16 bytes per cycle to set the limit to something resembling for the AGP/PCIe bus.  Take into account that the BW is at GPU or main clock frequency.  The value may be revised to take into account changes in PCIe spec and different GPU/main clock frequencies.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="StreamerFetchBusWidth"> StreamerFetchBusWidth </span></h3>
<p><b>  Description </b>
</p><p>Defines the bandwidth in bytes per cycle (GPU/main clock) between the Streamer Fetch unit (tasked with reading vertex indices from memory) and the Memory Controller.
</p><p>The usual value for the parameter is the maximum available bandwidth per cycle (64 until recently) as we aren't interested on simulating interconnection network limitations.  As this units usually consumes very little bandwith smaller numbers may not affect performance.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="StreamerLoaderBusWidth"> StreamerLoaderBusWidth </span></h3>
<p><b> Description </b>
</p><p>Defines the bandwidth in bytes per cycle (GPU/main clock) between a Streamer Loader and the Memory Controller.  Notice that the current implementation garantees a dedicated bus between each Streamer Loader instance and the Memory Controller so the aggregated bandwith may be much larger.
</p><p>The usual value for the parameter is the maximum available bandwidth per cycle (64 until recently) as we aren't interested on simulating interconnection network limitations.  When a single Streamer Loader is defined maxing the bandwidth is advisable to prevent performance degradation on vertex fetch limited cases.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ZStencilBusWidth"> ZStencilBusWidth </span></h3>
<p><b> Description </b>
</p><p>Defines the bandwidth in bytes per cycle (GPU/main clock) between a Z Stencil Test unit (ROPZ) and the Memory Controller. Notice that the current implementation garantees a dedicated bus between each ROPZ instance and the Memory Controller so the aggregated bandwith may be much larger. 
</p><p>The usual value for the parameter is the maximum available bandwidth per cycle (64 until recently) as we aren't interested on simulating interconnection network limitations.  Current recommendation is to always used the maximum bandwidth available as ROPZ is a large bandwith consumer.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ColorWriteBusWidth"> ColorWriteBusWidth </span></h3>
<p><b> Description </b>
</p><p>Defines the bandwidth in bytes per cycle (GPU/main clock) between a Color Write unit (ROPC) and the Memory Controller. Notice that the current implementation garantees a dedicated bus between each ROPC instance and the Memory Controller so the aggregated bandwith may be much larger. 
</p><p>The usual value for the parameter is the maximum available bandwidth per cycle (64 until recently) as we aren't interested on simulating interconnection network limitations. Current recommendation is to always used the maximum bandwidth available as ROPC is a large bandwith consumer.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="DACBusWidth"> DACBusWidth </span></h3>
<p><b> Description </b>
</p><p>Defines the bandwidth in bytes per cycle (GPU/main clock) between the DAC and the Memory Controller.
</p><p>The usual value for the parameter is the maximum available bandwidth per cycle (64 until recently) as we aren't interested on simulating interconnection network limitations. As we are mostly ignoring real screen refresh bandwidth consumption and the DAC is only used to dump the framebuffer for verification purposes we want to use the maximum bandwidth to reduce the number of cycles spent on the process.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureUnitBusWidth"> TextureUnitBusWidth </span></h3>
<p><b> Description </b>
</p><p>Defines the bandwidth in bytes per cycle (GPU/main clock) between a Texture Unit and the Memory Controller. Notice that the current implementation garantees a dedicated bus between each Texture Unit instance and the Memory Controller so the aggregated bandwith may be much larger. 
</p><p>The usual value for the parameter is the maximum available bandwidth per cycle (64 until recently) as we aren't interested on simulating interconnection network limitations. Current recommendation is to always used the maximum bandwidth available as the Texture Unit is a large bandwith consumer.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ReadBufferLines"> ReadBufferLines </span></h3>
<p><b> Description </b>
</p><p>Defines the number of lines in a buffer used to hold data already read from memory and pending to be issued (served) to the requesting GPU unit.  A line corresponds with the maximum transaction size (currently defined as a constant with value 64 bytes).
</p><p>Recommendation for this parameter is 128 or 256 lines as limits the number of requests that can be issued to memory due to lack of back pressure mechanism (lines are reserved before issuing the request to memory).  The parameter affects the backpressure mechanism between GPU units and the Memory Controller.  Due to the backpressure implementation at least 8 to 16 lines (depending on the number of GPU units attached to the Memory Controller) may be required and it must be taken into account that those entries will remain unused.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="WriteBufferLines"> WriteBufferLines </span></h3>
<p><b> Description </b>
</p><p>Defines the number of lines in a buffer used to hold data that is pending to be written to memory. A line corresponds with the maximum transaction size (currently defined as a constant with value 64 bytes).
</p><p>Recommendation for this parameter is 128 or 256 lines as limits the number of write transactions that can be pending in the Memory Controller.  The parameter affects the backpressure mechanism between GPU units and the Memory Controller.  Due to the backpressure implementation at least 8 to 16 lines (depending on the number of GPU units attached to the Memory Controller) may be required and it must be taken into account that those entries will remain unused.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="RequestQueueSize"> RequestQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the number of requests (transactions) that can be stored in the queue for memory transactions pending to be processed.
</p><p>Check if in Memory Controller V2 this parameter affects transactions after or before splitting.
</p><p>Recommendation for this parameter is 256 or 512 transactions.  It must be noted due to the backpressure mechanism between the Memory Controller and the GPU units at least 8 to 32 entries (depending on the number of units attached to the Memory Controller) would be required for the backpreassure mechanism to actually work.  Count that those 8-32 entries won't be ever filled due to the mechanism.  This parameter limits the number of pending transactions and has been proven that small numbers have a noticeable effect on performance.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ServiceQueueSize"> ServiceQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the number of transactions that can be pending to be serviced to a GPU unit.  The Memory Controller implements a queue per type of GPU unit (Streamer Fetch, Streamer Loader, ROPZ, ROPC, Texture Unit, Command Processor, DAC).
</p><p>Recommendation for this parameter is a value of 32 or 64 entries. 
</p><p><b> Format </b>
</p><p>Integer
</p>
<h2> <span class="mw-headline" id="Legacy_Memory_Controller_parameters"> Legacy Memory Controller parameters </span></h2>
<h3> <span class="mw-headline" id="MemoryClockMultiplier"> MemoryClockMultiplier </span></h3>
<p><b> Description </b>
</p><p>Unused.  Will be eventually removed.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="MemoryFrequency"> MemoryFrequency </span></h3>
<p><b> Description </b>
</p><p>Unused.  Will be eventually removed.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="MemoryBusWidth"> MemoryBusWidth </span></h3>
<p><b> Description </b>
</p><p>Unused.  May be used to replace some constants in the legacy Memory Controller that define the burst size and cycles per burst.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="MemoryBuses"> MemoryBuses </span></h3>
<p><b> Description </b>
</p><p>Defines the number of buses or channels to GPU memory devices in the legacy Memory Controller.
</p><p>The usual values for this parameter are 1, 2 or 4 or 8 buses/channels (64-bit, 128-bit, 256-bit or 512-bit memory interfaces).  At some point other values were tested and non power of two values are allowed due to the loose rules implemented in the legacy Memory Controller.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SharedBanks"> SharedBanks </span></h3>
<p><b> Description </b>
</p><p>In the legacy Memory Controller is used to allow any memory page to be accessed using any of the memory buses/channels as if there was a single memory device with multiple ports.
</p><p>Parameter exists due to a legacy implementation of the legacy Memory Controller.  Could be useful to simulate some kind of ideal memory.
</p><p>The parameter has not been set to TRUE in years.  Not much point on doing that.  The legacy Memory Controller right now is only useful for the simulator debug mode.
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="BankGranurality"> BankGranurality </span></h3>
<p><b> Description </b>
</p><p>The parameter actually defines how the memory devices (bus/channels, banks and pages) are mapped to linear GPU memory addresses.  The parameter defines the bank interleaving and implicitly bus/channel interleaving in the legacy Memory Controller.  The defined value is the interleaving in bytes for banks of different bus channels.  The bus/channel interleaving is applied after the bank interleaving&nbsp;:
</p>
<pre>aaaa aaaa ccbb bbbb
</pre>
<p>Where aaaaaaaa would be extra address bits, cc would define the bus/channel being accessed and bbbbbb would address data inside a bank in the defined bus/channel.
</p><p>The usual value for this parameter is 1024 bytes.  Only power of two values are likely to work correctly.  The value must be smaller than the value defined for MemoryPageSize.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ReadLatency"> ReadLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the latency in cycles of a read request (request to data available) to the memory device (aka CAS latency) in the legacy memory controller.
</p><p>Use values from GDDR2/GDDR3/GDDR4 device specifications.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="WriteLatency"> WriteLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the latency in cycles of a write request to a memory device, request to first data in, (aka write latency WL) in the legacy Memory Controller.
</p><p>Use values from GDDR2/GDDR3/GDDR4 device specifications.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="WriteToReadLatency"> WriteToReadLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the penalty in cycles from issuing a write to read request to a memory device (aka tWTR) in the legacy Memory Controller.  For the read to write penalty the value for read latency is used.
</p><p>Use values from GDDR2/GDDR3/GDDR4 device specifications.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="MemoryPageSize"> MemoryPageSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size in bytes of a page in a memory device (aka row size) in the legacy Memory Controller.
</p><p>The usual values are 4096 or 8192 bytes.  Non power of two values shouldn't work.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="OpenPages"> OpenPages </span></h3>
<p><b> Description </b>
</p><p>The parameter actually defines the number of banks per memory device (bus/channel) in the legacy Memory Controller.
</p><p>Normal values are 4 or 8 banks.  Use values from GDDR2/GDDR3/GDDR4 device specifications.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="PageOpenLatency"> PageOpenLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the latency in cycles of 'opening' a page in one of the banks of the memory device (bus/channel) in the legacy memory controller.  This parameter is the number of cycles between the request for opening the new page and when the first request can be issued to that page.  In a real GDDR model (Memory Controller V2) this corresponds with precharge, ACT and RAS and their associated latencies.
</p><p>Use values derived from GDDR2/GDDR3/GDDR4 device specifications.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h2> <span class="mw-headline" id="New_Memory_Controller_parameters_.28aka_MCV2.29"> New Memory Controller parameters (aka MCV2) </span></h2>
<h3> <span class="mw-headline" id="MemoryControllerV2"> MemoryControllerV2 </span></h3>
<p><b> Description </b>
</p><p>The parameter is used to select between the legacy Memory Controller (FALSE) and the detailed GDDR based Memory Controller V2.
</p><p>Always use MemoryControllerV2 when simulating for obtaining real performance numbers.  The legacy memory controller is required for some debug mode features.
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="V2MemoryChannels"> V2MemoryChannels </span></h3>
<p><b> Description </b>
</p><p>Defines the number of memory channels in the GPU memory controller V2. Each channel has an independent memory scheduler and GDDRX chip. The interface of the GDDRX is fixed to 32-bit.
</p><p>The usual values for this parameter are 1, 2, 4, 8 or 16 channels (32 and more channels are supported also). It is possible to use non power of two values for this parameter but with some limitations (see V2SplitterType).
</p><p>Although the data-pin interface of the GDDRX chips is fixed to 32-bit it is easy to simulate configurations with 64-bit per channel, 128-bit and so on. For example, 64-bit per channel interfaces are implemented in real hardware having two 32-bit chips attached to one single channel (these two chips receive exactly the same stream of DDR commands). In our model, this can be achieved doubling the data rate of the chip (see V2BurstBytesPerCycle ) and doubling the row capacity (see V2MemoryRowSize).
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="V2BanksPerMemoryChannel"> V2BanksPerMemoryChannel </span></h3>
<p><b> Description </b>
</p><p>Defines the number of banks contained into a single GDDRX chip. The number of banks per chip amounts to the maximum number of open pages per chip (each bank can have only one page opened).
</p><p>The usual value for this parameter is 8 (typical value in GDDR3/4 memories)
</p><p><b> Format </b>
</p><p>Integer 
</p><p>Integer (multiples of 2048)
</p>
<h3> <span class="mw-headline" id="V2MemoryRowSize"> V2MemoryRowSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size in bytes of the rows (aka pages) in the GDDR3/4 memory banks.
</p><p>The usual value is 2048 (the usual value in GDDR3/4 memories ). This value can be set to multiples of 2048 in case we are interested in simulate interfaces bigger than 32-bit per channel (see also V2BurstBytesPerCycle).
</p><p><b> Format </b>
</p><p>Integer (multiples of 2048)
</p>
<h3> <span class="mw-headline" id="V2BurstBytesPerCycle"> V2BurstBytesPerCycle </span></h3>
<p><b> Description </b>
</p><p>Defines the number of bytes transmitted per cycle.
</p><p>The usual value is 8 (for DDR memories)
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="V2SplitterType"> V2SplitterType </span></h3>
<p>This parameter allows selecting between two memory transaction splitters/distributors available in the Memory Controller.
</p><p>The two splitters are compatible with the parameter V2SecondInterleaving and depend on parameters V2MemoryChannels and V2BanksPerMemoryChannel.
</p><p>The two splitters/distributors initially split each received memory transaction in what we call channel transactions, channel transactions are the work unit processed by channel schedulers. After this common splitting/distributing process, each splitter distributes channel transactions using its own scheme described below.
</p>
<dl><dt>V2SplitterType = 0</dt><dd>
</dd></dl>
<p>This memory transaction splitter/distributor selects the destination channel and bank using the parameters V2ChannelInterleaving and V2BankInterleaving (and V2SecondChannelInterleaving and V2SecondBankInterleaving if V2SecondInterleaving is set to TRUE).
The process to obtain the target channel and bank is the following:
</p><p>The parameter V2ChannelInterleaving is used to <b>extract</b> the target channel, once the channel bits has been extracted the bank bits are extracted using the parameter V2BankInterleaving. Note that bits are truly extracted, so <b>bank bits displacement</b> has to be taken into account after extracting channel bits (this situation occurs when V2BankInterleaving multiplied by V2BanksPerMemoryChannel is equal or greater than V2ChannelInterleaving).
</p>
<dl><dd><b>Example</b>: 
</dd><dd>V2SecondInterleaving = FALSE
</dd><dd>V2MemoryChannels = 8
</dd><dd>V2BanksPerMemoryChannel = 8
</dd><dd>V2ChannelInterleaving = 512
</dd><dd>V2BankInterleaving = 128
</dd></dl>
<dl><dd>The binary address is decoded as follows: 
<ul><li>Address in binary format = X.X.X.X.X.X.X.X.X.X.X.X.X.X.X.B2.C2.C1.C0.B1.B0.X.X.X.X.X.X.X
</li><li>Channel bits are extracted, channel selected using: C2.C1.C0
</li><li>Remaining bits: X.X.X.X.X.X.X.X.X.X.X.X.X.X.X.B2.B1.B0.X.X.X.X.X.X.X
</li><li>Bank bits are extracted, bank selected using: B2.B1.B0
</li><li>The remaining bits are used to select the row and the start column.
</li></ul>
</dd></dl>
<dl><dt>V2SplitterType = 1</dt><dd> 
</dd></dl>
<p>This memory transaction splitter selects the destination channel and bank using the parameters V2ChannelInterleavingMask and V2BankInterleavingMask (and V2SecondChannelInterleavingMask and V2SecondBankInterleavingMask if V2SecondInterleaving is set to TRUE).
The process to obtain the channel and bank destination is based on a string mask specifying which bits compound the channel and the bank (note that <b>bank bits displacement</b> is now avoided), with this splitter is also possible to select random (not consecutive) bits to compound the channel and the bank bits.
</p><p>The string mask format is a list of integers representing bit positions. Examples of valid strings are: "10 9 8", "8 9 10", "12 14 6", etc.
Note that the first and the second examples are not equivalent, since the order is taken into account. If bits 10, 9 and 8 are respectively 110 the first mask string will produce the value 6 (110) and the second mask string will produce 3 (011). 
</p>
<dl><dd><b>Example</b>: 
</dd><dd>V2SecondInterleaving = FALSE
</dd><dd>V2MemoryChannels = 8
</dd><dd>V2BanksPerMemoryChannel = 8
</dd><dd>V2ChannelInterleavingMask = "10 9 8"
</dd><dd>V2BankInterleaving = "14 12 11"
</dd></dl>
<dl><dd>The binary address is decoded as follows: 
<ul><li>Address in binary format = X.X.X.X.X.X.X.X.X.X.X.X.X.B0.X.B1.B2.C2.C1.C0.X.X.X.X.X.X.X.X
</li><li>Channel bits used to select the channel: C2.C1.C0
</li><li>Bank bits used to select the bank: B2.B1.B0
</li><li>Extract channel and bank bits, the remaining bits are used to select the row and the start column.
</li></ul>
</dd></dl>
<h3> <span class="mw-headline" id="V2ChannelInterleaving"> V2ChannelInterleaving </span></h3>
<p><b> Description </b>
</p><p>Defines how the linear memory is assigned/interleaved among the available physical memory channels. This assignment/interleaving is expressed in bytes. This parameter is only used when V2SplitterType=0.
</p><p>Usual values are 256, 512, 1024 and 2048
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="V2BankInterleaving"> V2BankInterleaving </span></h3>
<p><b> Description </b>
</p><p>Defines how the memory handled by each channel is arranged among its banks. Note that channel interleaving is first applied and then the bank interleaving is applied to select the corresponding bank within the channel. This parameter is only used when V2SplitterType=0.
</p><p>Usual values are 256, 512, 1024, 2048 and 4096
</p><p><b> Format </b>
</p><p>Integer
</p><p><br>
</p>
<h3> <span class="mw-headline" id="V2ChannelInterleavingMask"> V2ChannelInterleavingMask </span></h3>
<p><b> Description </b>
</p><p>Defines how the linear memory is assigned/interleaved among the available physical memory channels. This assignment/interleaving is expressed using a bit mask. This parameter is only used when V2SplitterType=1.
</p><p>Usual values are "10 9 8", "11 10 9", "12 11 10" and "13 12 11" (these values are equivalent to V2ChannelInterleaving = 256, 512, 1024 and 2048 using V2SplitterType=0)
</p><p><b> Format </b>
</p><p>String
</p>
<h3> <span class="mw-headline" id="V2BankInterleavingMask"> V2BankInterleavingMask </span></h3>
<p><b> Description </b>
</p><p>Defines how the memory handled by each channel is arranged among its banks. This parameter is only used when V2SplitterType=1.
</p><p>Usual values are "12 11 10", "14 10 9", "14 13 12" and so on
</p><p>It is mandatory that channel and bank mask are disjoint
</p><p>V2ChannelIntreleavingMask="12 11 10" and V2BankInterleavingMask="14 13 9" is CORRECT
V2ChannelIntreleavingMask="12 11 10" and V2BankInterleavingMask="14 13 12" is NOT CORRECT (bit 12 is used in both masks)
</p><p><b> Format </b>
</p><p>String
</p><p><br>
</p>
<h3> <span class="mw-headline" id="V2SecondInterleaving"> V2SecondInterleaving </span></h3>
<p><b> Description </b>
</p><p>This parameter enables a second interleaving space. Thus, the linear memory is split into two disjoint segments, the first segment from address 0 to N-1 uses the first interleaving (V2ChannelInterleaving/V2ChannelInterleavingMask and V2BankInterleaving/V2BankInterleavingMask) and the second segment, from address N to MAX_MEMORY_ADDRESS, uses the second interleaving defined in V2SecondChannelInterleaving/V2SecondChannelInterleavingMask and V2SecondBankInterleaving/V2SecondBankInterleavingMask.
</p><p>The value of N is contained in the Memory Controller's register: MCV2_2ND_INTERLEAVING_START_ADDR. The current driver implementation sets this value to map Color/Z buffers into first address segment and the rest (texture data, vertex data and so on) into the second segment
</p><p><b> Format </b>
</p><p>Boolean
</p>
<h3> <span class="mw-headline" id="V2SecondChannelInterleaving"> V2SecondChannelInterleaving </span></h3>
<p>Analogous to 'V2ChannelInterleaving' for the second interleaving
</p>
<h3> <span class="mw-headline" id="V2SecondBankInterleaving"> V2SecondBankInterleaving </span></h3>
<p>Analogous to 'V2BankInterleaving' for the second interleaving
</p>
<h3> <span class="mw-headline" id="V2SecondChannelInterleavingMask"> V2SecondChannelInterleavingMask </span></h3>
<p>Analogous to 'V2ChannelInterleavingMask' for the second interleaving
</p>
<h3> <span class="mw-headline" id="V2SecondBankInterleavingMask"> V2SecondBankInterleavingMask </span></h3>
<p>Analogous to 'V2BankInterleavingMask' for the second interleaving
</p>
<h3> <span class="mw-headline" id="V2BankSelectionPolicy"> V2BankSelectionPolicy </span></h3>
<h3> <span class="mw-headline" id="V2ChannelScheduler"> V2ChannelScheduler </span></h3>
<h3> <span class="mw-headline" id="V2PagePolicy"> V2PagePolicy </span></h3>
<h3> <span class="mw-headline" id="V2MaxChannelTransactions"> V2MaxChannelTransactions </span></h3>
<h3> <span class="mw-headline" id="V2MemoryTrace"> V2MemoryTrace </span></h3>
<h3> <span class="mw-headline" id="V2DisableActiveManager"> V2DisableActiveManager </span></h3>
<h3> <span class="mw-headline" id="V2DisablePrechargeManager"> V2DisablePrechargeManager </span></h3>
<h3> <span class="mw-headline" id="V2ManagerSelectionAlgorithm"> V2ManagerSelectionAlgorithm </span></h3>
<h3> <span class="mw-headline" id="V2MemoryType"> V2MemoryType </span></h3>
<h3> <span class="mw-headline" id="V2GDDR_Profile"> V2GDDR_Profile </span></h3>
<h3> <span class="mw-headline" id="V2GDDR_tRRD"> V2GDDR_tRRD </span></h3>
<h3> <span class="mw-headline" id="V2GDDR_tRCD"> V2GDDR_tRCD </span></h3>
<h3> <span class="mw-headline" id="V2GDDR_tWTR"> V2GDDR_tWTR </span></h3>
<h3> <span class="mw-headline" id="V2GDDR_tRTW"> V2GDDR_tRTW </span></h3>
<h3> <span class="mw-headline" id="V2GDDR_tWR"> V2GDDR_tWR </span></h3>
<h3> <span class="mw-headline" id="V2GDDR_tRP"> V2GDDR_tRP </span></h3>
<h3> <span class="mw-headline" id="V2GDDR_CAS"> V2GDDR_CAS </span></h3>
<h3> <span class="mw-headline" id="V2GDDR_WL"> V2GDDR_WL </span></h3>
<h1> <span class="mw-headline" id="STREAMER_section"> STREAMER section </span></h1>
<h2> <span class="mw-headline" id="Vertex_Cache_and_Streamer_Commit_parameters"> Vertex Cache and Streamer Commit parameters </span></h2>
<h3> <span class="mw-headline" id="IndicesCycle"> IndicesCycle </span></h3>
<p><b> Description </b>
</p><p>Defines the number of vertex indices that are read/generated and processed per cycle in the Streamer.
</p><p>The parameter limits the maximum vertex and triangle througput of the geometry pipeline (even if the draw call is not indexed!).
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="IndexBufferSize"> IndexBufferSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size in bytes of the buffer in Streamer Fetch to store index data read from memory.
</p><p>The parameter should be set to a size multiple of the memory transaction size.  The size doesn't needs to be that large, just enough to hide some of the latency of the memory requests in the rare case that indices have to be generated at a fast rate.  A normal tested value would be 2 or 4 KBytes.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="OutputFIFOSize"> OutputFIFOSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the vertex reorder queue in the Streamer Commit used to keep the order of shaded vertices with shader processors that may shade vertices out of order.  The parameter defines one of the limits of the post-shading vertex cache.
</p><p>The parameter limits the number of vertices that can be processed at the same time in the shader processors.  It's associated with the OutputMemorySize parameter.
</p><p>In the unified shader model it may useful for hundred of vertices to be in the shader processors at the same time so the recommendation is to set this parameter to a high number.  The value assigned to the parameter may be higher than the value assigned to OutputMemorySize as it's very likely reuse of the shaded vertices (multiple instances) at rates as high as 2:1 or 3:1.  Some tested values have been 512 or 768.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="OutputMemorySize"> OutputMemorySize </span></h3>
<p><b> Description </b>
</p><p>Defines the size in vertices (a vertex can be associated with up to 16 128-bit attributes!) of the post shading vertex cache.  In the current implementation this corresponds with the storage memory for vertices pending from being shaded and each position is linked to the reorder queue (size defined by the OutputFIFOSize parameter).  As a backpressure mechanism is not implemented with the shader processors or the Shader Work Distributor (FragmentFIFO) entries in this memory are reserved when the vertex is sent to the shader processors or the Shader Work Distributor.  Therefore the size of the memory limits the number of vertices that can be on execution on the shader processors at any time.
</p><p>As it limits the number of vertices being shaded a large number will be interesting for the unified shader model.  The number can be smaller than the defined for the reorder queue (OutputFIFOSize parameter) as it is to be expected some index/vertex reuse (different instances of the same index/vertex that hit the post shading vertex cache will share the same entry in the memory).  Tested values range from 512 to 768.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="VerticesCycle"> VerticesCycle </span></h3>
<p><b> Description </b>
</p><p>Defines the number of vertices that are processed in the Streamer per cycle.  In the current implementation this parameter only affects the throughput from Streamer Commit to Primitive Assembly.
</p><p>This parameter limits the triangle throughput of the geometry pipeline.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="AttributesSentCycle"> AttributesSentCycle </span></h3>
<p><b> Description </b>
</p><p>Defines the number of vertex attributes per vertex per cycle that can be transmitted from Streamer Commit to Primitve assembly.  Keep in mind that this value is per vertex processed/issued so the actual bandwidth between Streamer and Primitive assembly is the attribute maximum size (128 bits) multipled by the value of this parameter and by the value of the VerticesCycle parameter.
</p><p>If you don't want to be limited by communication between Streamer and Primitive Assembly set this to some large number.  Usual value is 4 attributes per cycle.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h2> <span class="mw-headline" id="Streamer_Loader_parameters"> Streamer Loader parameters </span></h2>
<h3> <span class="mw-headline" id="StreamerLoaderUnits"> StreamerLoaderUnits </span></h3>
<p><b> Description </b>
</p><p>The current implementation of the Streamer accepts multiple instances of the Streamer Loader unit to maximize vertex/attribute output to the shader processors.  This parameter defines the number of instances of the Streamer Loader unit.
</p><p>Unless the modeled architecture is targeted to heavy triangle throughput architecture usual values would be just 1 or 2 instances.  Even if the architecture tries to maximize triangle throughput a relatively small number of instances (4 to 8) will likely saturate the available bandwidth from GPU memory so setting this parameter to a high number is not useful.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SLIndicesCycle"> SLIndicesCycle </span></h3>
<p><b> Description </b>
</p><p>Defines the number of indices/vertices per cycle that can be processed by an instance of the Streamer Loader unit.
</p><p>When the StreamerLoaderUnits is set to 1 the value of this parameter should match the value of the IndicesCycle parameter.
</p><p>Check what are the requirements when StreamerLoaderUnits is higher than 1.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SLInputRequestQueueSize"> SLInputRequestQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the structure (FIFO) that stores information for requests to memory.  Each entry in the structure is associated with an index/vertex and holds information associated with each of the attributes defined for the vertex.  So the actual number of memory transactions that can be tracked is as high as the defined value multiplied by two times (in case of splited accesses to two cache lines) the attributes per vertex.
</p><p>Set this parameter to a relatively high number to hide memory access latency.  An usual value is 128 entries.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SLAttributesCycle"> SLAttributesCycle </span></h3>
<p><b> Description </b>
</p><p>Defines the number of vertex attributes that are processed per cycle by a Streamer Loader unit.  Processing includes default value generation, address generation and cache access. 
</p><p>The parameter affects the bandwidth between the Streamer Loader unit and it's associated Input Cache.  A 'port' with the Input Cache is defined for each attribute that can be processed per cycle.  Each 'port' allows an independent access (set, line, line offset) to the Input Cache.
</p><p>Realistically the value of this parameter shouldn't be that high but if the purpose is to saturate as much possible the memory subsystem with just one or two Streamer Loader units it can be set to a high value.  Usual values used are 4 o 8 attributes per cycle.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SLInputCacheLines"> SLInputCacheLines </span></h3>
<p><b> Description </b>
</p><p>Defines the number of cache lines in the Input Cache associated with a Streamer Loader unit.
</p><p>The Input Cache line is fully associative so the parameter defines the actual number of lines in the cache.
</p><p>The Input Cache doesn't need to be very large (4 KB - 8 KB).  An usual value used is 32 lines associated with 256 byte lines.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SLInputCacheLineSize"> SLInputCacheLineSize </span></h3>
<p><b> Description </b>
</p><p>Defines the bytes per cache line in the Input Cache associated to a Streamer Loader unit.
</p><p>Along with the SLInputCacheLines parameter defines the actual size of the Input Cache.
</p><p>Any power of two value is allowed for this cache.  However sizes smallers than a memory transaction (defined as 64 bytes in the current implementation) are not recommended for obvious reasons.  The usual value we are using right now is 256 bytes.  However it's likely we would want to reduce this size to a more reasonable 64 or 128 bytes per line.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SLInputCachePortWidth"> SLInputCachePortWidth </span></h3>
<p><b> Description </b>
</p><p>Defines the width in bytes of a read 'port' between the Input Cache and the associated Streamer Loader unit.  The actual bandwidth between the Input Cache and the Streamer Loader unit can be obtained multiplying the value of the SLAttributesCycle parameters (defines the number of 'ports' to the cache) with the value of this parameter.
</p><p>An usual value is 16 bytes as that's the maximum size of a vertex attribute.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SLInputCacheRequestQueueSize"> SLInputCacheRequestQueueSize </span></h3>
<p><b> Description </b>
</p><p>The Input Cache uses the Fetch Cache and the Fetch Cache implements a structure (FIFO) that stores the information about pending cache line fill and spill (not in this case as the Input Cache is read only) requests.
</p><p>The value of this parameter limits the number of pending memory transactions that the Input Cache can support.  The actual number of pending memory transactions is obtained by dividing the cache line size by the memory transaction size.  Small numbers will limit the latency hiding capabilites of the Input Cache and Streamer Loader unit.  Currently we are using a value of 32 requests.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SLInputCacheInputQueueSize"> SLInputCacheInputQueueSize </span></h3>
<p><b> Description </b>
</p><p>Due to the specific implementation there is an additional structure (FIFO) inside Input Cache that tracks the state of the cache line fill/spill requests.  This parameter defines the size of this structure.
</p><p>As the SLInputCacheRequestQueueSize parameter this parameter limits the number of pending memory transactions that the Input Cache can generate and thus how much memory latency can the Input Cache and Streamer Loader unit hide.  The actual number of possible pending memory transactions is the minimum of both parameters so they are usually set to the same value.  The current value we are using is 32 entries/requests.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h1> <span class="mw-headline" id="VERTEXSHADER_section"> VERTEXSHADER section </span></h1>
<p>The parameters in this section are only used by the legacy non-unified shader model.
</p><p>The legacy non-unified shader model has not been tested in years so it may not even work.
</p><p><br>
</p>
<h3> <span class="mw-headline" id="ExecutableThreads_.28VSH.29"> ExecutableThreads (VSH) </span></h3>
<p><b> Description </b>
</p><p>Number of executable 'threads' in the vertex shader processor.  A thread in this case corresponds with a vertex element.
</p><p>The number assigned to this parameter must be a multiple of the assigned to the ThreadGroup parameter.
</p><p>As this parameter is for old style specific purpose vertex shader, which didn't even implement texture loads in most case, the value doesn't need to be very large.  Just enough to hide the ALU pipeline, data dependencies and vertex in/out traffic with the Streamer.  For example as a vestige of the old days the value in our current configuration files is 12.  Given that the maximum latency is around 9 that would cover even the worst dependencies and a couple threads being frozen for input/output from/to the Streamer.
</p><p><b> Type </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="InputBuffers_.28VSH.29"> InputBuffers (VSH) </span></h3>
<p><b> Description </b>
</p><p>For some reason in the first implementation of the shader processor model there was a difference between storage for shader elements (vertices or fragments) that were being received from the producer unit (Streamer or FragmentFIFO) and storage and state for actual runnable threads for shader elements.  This parameter represents how much storage is used for those elements that are being loaded but can not execute until a free runnable thread is available.
</p><p>The number assigned to this parameter must be a multiple of the defined for the ThreadGroup parameter.
</p><p>Large values are not required.  For the vertex shaders any value is fine.  The value in our current configuration files is 4.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ThreadResources_.28VSH.29"> ThreadResources (VSH) </span></h3>
<p><b> Description </b>
</p><p>In the current implementation resources mean registers to store temporal data for the shader elements.  At some point a resource represented two registers allocated as a pair but I think that was changed to represent a single register (128 bits).  The actual meaning is mainly controlled by the API/Driver implementation which is the one that decides how many resources requires a shader program to execute.  The shader processor logic also takes into account the number of input or output attributes defined with the shader program to compute the resources to reserve per shader element.
</p><p>The value represents the total number of resources for each instance of the shader processor.  Each shader thread (actually an element) has to reserve the required amount of resources before it can start executing.
</p><p>The value limits how many shader threads/elements can be in execution at any point and depends on the loaded shader program.
</p><p>The value assigned to this parameter must be equal or greater than the value assigned to the ExecutableThreads parameter.  At least a resource per thread is required or the actual number of executable threads would never be reached.
</p><p>In this case as vertex programs are relatively large and require large number of input and output attributes and temporal registers a high number of resources relative to the small number of threads is desired so that all the threads will have available resources.  In our current configuration files the value is 128.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ThreadRate_.28VSH.29"> ThreadRate (VSH) </span></h3>
<p><b> Description </b>
</p><p>Defines how many shader threads (really elements) are executed per cycle.  In this case executed means: fetching an instruction for the shader thread, decoding, executing and commiting the instruction.  All the shader threads/elements may execute the same instruction in lock step or execute independently the program depending on the value of the LockedExecutionMode parameter.
</p><p>The value assigned to this parameter must be equal or greater than 1.
</p><p>For the vertex shader the normal implementation is that a single thread/element can be executed.  That's the value in our current configuration files.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="FetchRate_.28VSH.29"> FetchRate (VSH) </span></h3>
<p><b> Description </b>
</p><p>Defines how many instructions are fetched and then decoded, executed and commited per thread/element per cycle.  Actually defines the ALU architecture: SIMD4, 2xSIMD4, 3xSIMD4, ... or as a special case SIMD4+scalar.
</p><p>A value greater than 1 represents a super scalar implementation.  In the current implementation and for the vertex shader using the legacy shader model the instruction and associated ALU is for SIMD4 data.  An alternative architecture that combines a SIMD4 ALU/instruction with a scalar ALU/instruction per cycle is enabled using the ScalarALU parameter.
</p><p>The value assigned to this parameter must be equal or greater than 1.
</p><p>For the vertex shader the usual value would be 2 and then ScalarALU would be set to TRUE to implement a SIMD4+scalar.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ThreadGroup_.28VSH.29"> ThreadGroup (VSH) </span></h3>
<p><b> Description </b>
</p><p>Defines how many threads/elements are processed as a single group, ganged or working like a team.  Thread groups actually only have a meaning when the LockedExecutionMode parameter is set to TRUE and all the threads/elements in the group execute the same instructions in lock-step mode which basically simulates a kind of vector architecture with a single thread state (PC) associated to a group of elements/threads.
</p><p>The value of this parameter must be equal or greater than 1.
</p><p>For the vertex shader lock-step execution mode is not desired and therefore the value of this parameter uses to be 1.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="LockedExecutionMode_.28VSH.29"> LockedExecutionMode (VSH) </span></h3>
<p><b> Description </b>
</p><p>In the old shader model this parameter defines if shader threads/elements in a group are executed in lock step.  All the threads/elements in the group execute the same instruction(s) using a SIMD execution model and share the same thread information (PC, state).
</p><p>However for the legacy vertex shader the usual configuration is a single thread and even in case multiple threads are supported it would be reasonable a MIMD execution model.  In our current configuration files the value of this parameter is FALSE.
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="ScalarALU_.28VSH.29"> ScalarALU (VSH) </span></h3>
<p><b> Description </b>
</p><p>Defines in the old shader model if the ALU configuration is SIMD4+scalar.  The scalar ALU can be used for scalar instructions and vector instructions (not dot products) with a single result component.
</p><p>The FetchRate must be configured to 2 to enable this option.
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="ThreadWindow_.28VSH.29"> ThreadWindow (VSH) </span></h3>
<p><b> Description </b>
</p><p>Defines the method implemented to select the next thread to execute.  If the parameter is enabled a Thread Window will select the next ready thread from the pool of currently executing threads (round robin priority if multiple threads are ready).  If the parameter is disabled a thread queue will be implemented and only the head of the queue will be selectable for executing.  If the thread in the head is not ready instructions won't be fetched that cycle.
</p><p>The usual parameter for the vertex shader is to enable the Thread Window.  The number of threads implemented in the vertex shader is small so the cost is reduced.
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="FetchDelay_.28VSH.29"> FetchDelay (VSH) </span></h3>
<p><b> Description </b>
</p><p>Defines the minimum number cycles between instruction fetches for a group of threads/elements.  This parameter has a meaning when the thread group is large and requires multiple cycles to fully execute in the shader ALUs (vector length &gt; number vector ALUs).
</p><p>In the legacy vertex shader this parameter should always be 0 as the usual configuration has no thread group.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SwapOnBlock_.28VSH.29"> SwapOnBlock (VSH) </span></h3>
<p><b> Description </b>
</p><p>Defines the event that triggers the switch from the current executing thread group to the next thread group to execute.  If the parameter is set to FALSE each fetch cycle (fetch cycles may happen every cycle or every N cycles) a new thread group is selected for execution in round robin order.  Only if there is a single ready thread group will the same thread group fetch instructions in the consecutive fetch cycles.  When the parameter is set to TRUE a new thread will be selected only when the executing thread group is blocked, either because of a texture operation or because the shader program end was reached.
</p><p>For the legacy vertex shader this parameter is not really useful as the legacy vertex shader doesn't support texture instructions.
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="InputsPerCycle_.28VSH.29"> InputsPerCycle (VSH) </span></h3>
<p><b> Description </b>
</p><p>Defines how many shader elements (vertices) can be received from the producer unit per cycle.  In the case of the Vertex Shader the producer are the StreamerLoader units.
</p><p>The value assigned to this parameter must be equal or greater than 1.
</p><p>The value of this parameter depends on the capacity of the Vertex Shaders and the Streamer Loader to produce and process vertices.  As the configured number of vertex shaders uses to be higher than the capacity of the Streamer Loader the normal value is one input per cycle.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="OutputsPerCycle_.28VSH.29"> OutputsPerCycle (VSH) </span></h3>
<p><b> Description </b>
</p><p>Defines how many shader elements (vertices) can be sent per cycle to the consumer units (Streamer Commit for the legacy vertex shader).
</p><p>The value assigned to this parameter must be equal or greater than 1.
</p><p>The value of this parameter is affected by the processing capacity of the configured vertex shaders and the consuming capacity of the Streamer Commit unit.  The combined capacity of the configured vertex shaders uses to be larger than the capacity of the Streamer Commit unit so the normal value for a single vertex shader is one output per cycle.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="OutputLatency_.28VSH.29"> OutputLatency (VSH) </span></h3>
<p><b> Description </b>
</p><p>Defines the number of cycles required for a shader element (vertices) to reach the consumer unit from the shader processor.  Simulates a delay due to the location of the shader processor and location of geometry pipeline on the die.
</p><p>For a legacy vertex shader given that the number of cycles that a shader element can spend executing can be quite large it's unclear the performance effect of this parameter.
</p><p>The actual implementation is a bit more complex.  The parameter defines the maximum latency of the output signal from the vertex shader to the Streamer Commit unit.  The actual latency of a shader element sent through the signal depends on the number of output attributes for the element and a couple of constants.  The maximum latency is only reached when all 16 vertex output attributes are enabled.
</p><p>The value assigned to this parameter must be equal or greater than 1.
</p><p>In our current configurations the value used is 11 cycles.  It's not advisable to change this number in the current implementation.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h1> <span class="mw-headline" id="PRIMITIVEASSEMBLY_section"> PRIMITIVEASSEMBLY section </span></h1>
<h3> <span class="mw-headline" id="VerticesCycle_2"> VerticesCycle </span></h3>
<p><b> Description </b>
</p><p>Defines the number of shaded vertices that the Primitive Assembly stage can receive per cycle from Streamer Commit.
</p><p>This parameter limits the throughput in vertices (and triangles) of the geometry pipeline.
</p><p>An usual value for this parameter is 2 unless the architecture to simulate requires a higher triangle throughput.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TrianglesCycle"> TrianglesCycle </span></h3>
<p><b> Description </b>
</p><p>Defines the triangle output per cycle from the Primitive Assembly stage to the Clipper stage.
</p><p>This parameter limits the triangle throughput of the geometry pipeline.
</p><p>A normal value is 2 triangles per cycle but architectures with higher triangle throughput requirements may use higher values.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="InputBusLatency"> InputBusLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the latency in cycles for vertices sent from Streamer Commit to the Primitive Assembly stage.
</p><p>The purpose of the parameter was to define some delay due to bandwith limitations between Streamer Commit and Primitive Assembly and the location of Primitive Assembly and Streamer Commit on the die.  The actual implementation uses this value as just on die distance limitation.  The number of attributes per cycle defined for the Streamer unit increases the basic latency depending on the number of vertex output attributes defined.
</p><p>In our current configuration files the value is set to 10 cycles.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="AssemblyQueueSize"> AssemblyQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the number of vertices that can be stored in the Primitive Assembly queue.
</p><p>The number of entries in the queue must be at least 4 to support quad strips.  The number of entries has to be larger than the vertex/triangle rate.
</p><p>Our current configuration defines a value of 32 entries.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h1> <span class="mw-headline" id="CLIPPER_section"> CLIPPER section </span></h1>
<h3> <span class="mw-headline" id="TrianglesCycle_2"> TrianglesCycle </span></h3>
<p><b> Description </b>
</p><p>Defines the number of triangles that the Clipper stage can receive, processes and sent per cycle.
</p><p>The value of the parameter limits the throughput of the geometry pipeline.
</p><p>The usual value is 2 triangles per cycle but higher values can be used for architectures with a requirement for high triangle throughput.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ClipperUnits"> ClipperUnits </span></h3>
<p><b>  Description </b>
</p><p>Defines the number of Triangle Clipping units implemented in the Clipper stage.  Each unit can process one triangle.
</p><p>In the current implementation the value for this parameter must match the value of the TrianglesCycle parameter.
</p><p>The usual value is 2 units, but higher values are possible for architectures with higher triangle throughputs.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="StartLatency"> StartLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the startup latency, as the number of cycles between consecutive triangles issued to the unit, of the Clipping units in the Clipper stage.
</p><p>This parameter limits the throughput of the geometry pipeline.
</p><p>An usual value for this parameter is 1 cycle.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ExecLatency"> ExecLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the number of cycles a triangle must spend on a Clipping unit.
</p><p>Our current configuration files set a value of 6 cycles.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ClipBufferSize"> ClipBufferSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer that holds triangles received from the Primitive Assembly stage and that are waiting to be processed in a Triangle Clipping unit.
</p><p>In the current implementation the number of entries must be at least 3 times the triangle processing rate defined by the TrianglesCycle parameter.
</p><p>In our current configuration files the value of this parameter is 32 entries.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h1> <span class="mw-headline" id="RASTERIZER_Section"> RASTERIZER Section </span></h1>
<h2> <span class="mw-headline" id="Triangle_Setup_parameters"> Triangle Setup parameters </span></h2>
<h3> <span class="mw-headline" id="TrianglesCycle_3"> TrianglesCycle </span></h3>
<p><b> Description </b>
</p><p>Defines how many triangles can be received, processed and sent by the Triangle Setup unit.
</p><p>This parameter limits the triangle throughput of the geometry pipeline.
</p><p>An usual value for this parameter is 2 triangles cycles.  Higher values can be defined if the simulated architecture has a high triangle throughput requirement.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SetupFIFOSize"> SetupFIFOSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) for triangles received from the Clipper stage and waiting to be processed by the Triangle Setup unit.
</p><p>The value assigned to this parameter must be at least TrianglesPerCycle * (TriangleInputLatency + 1).
</p><p>Our current configuration files use a value of 32 triangles.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SetupUnits"> SetupUnits </span></h3>
<p><b> Description </b>
</p><p>Defines how many Triangle Setup units have been implemented.  The parameter defines how many triangles can start processing each cycle.
</p><p>This parameter limits the triangle throughput of the geometry pipeline-
</p><p>The value of this parameter should be at least equal to the value defined for TrianglesCycle parameter.
</p><p>An usual value is 2 units but higher numbers can be defined for simulated architectures with a high triangle throughput.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SetupLatency"> SetupLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the number of cycles required to setup a triangle in one of the Triangle Setup units.
</p><p>The usual value is 10 cycles.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SetupStartLatency"> SetupStartLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the number of cycles between consecutive triangles issued to the same Triangle Setup unit.
</p><p>This parameter limits the triangle throughput of the geometry pipeline.  Higher values in this parameter can be compensated by increasing the number of Triangle Setup units.
</p><p>Our current configuration files use a value of 4 cycles.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TriangleInputLatency"> TriangleInputLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the latency in cycles for triangles received from the Clipper stage.
</p><p>The actual implementation is the latency in cycles of the triangle signal from the Clipper box.
</p><p>The usual value for this parameter is 2 cycles.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TriangleOutputLatency"> TriangleOutputLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the latency in cycles of triangles sent to the Triangle Traversal/Fragment Generation stage.
</p><p>The actual implementation is the latency of the signal from Triangle Setup to Triangle Traversal box.
</p><p>The usual value for this parameter is 2 cycles.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TriangleSetupOnShader"> TriangleSetupOnShader </span></h3>
<p><b> Description </b>
</p><p>Enables a hack for executing part of the triangle setup computations (setup matrix, matrix determinant, edge and z equations) on the shader processor.  The shader program is executed as a special vertex program that receives the positions of three vertices as the input for a triangle.
</p><p>This option can only be enabled when using the unified shader model.
</p><p>We have not tested this hack for years so it may no longer work.
</p><p>The usual value for this parameter is FALSE
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="TriangleShaderQueueSize"> TriangleShaderQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the reorder buffer (FIFO) used to store triangles pending to be processed by the triangle setup shader program or that are currently being processed in the shaders.
</p><p>The value of this parameter can not be zero if triangle setup on the shader is enabled.
</p><p>The value assigned to this parameter in the current implementation limits the number of triangles that can be on the shader processors at any time.
</p><p>Triangle setup on the shader has not been used in years so it may not work.
</p><p>Our current configuration files use a value of 32 triangles. 
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="EmulatorStoredTriangles"> EmulatorStoredTriangles </span></h3>
<p><b> Description </b>
</p><p>Defines the maximum number of triangles that the Rasterizer Emulator class can track as being processed through the Triangle Setup, Triangle Traversal and Interpolator boxes.
</p><p>This parameter may limit the number of triangles being processed in the Triangle Setup, Triangle Traversal and Interpolator stages.  The current implementation may just trigger a panic if the limit is reached.
</p><p>Our current configuration files use a value of 64 triangles.  As far as I know the limit has never been reached.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h2> <span class="mw-headline" id="Rasterization_parameters"> Rasterization parameters </span></h2>
<h3> <span class="mw-headline" id="StampsPerCycle"> StampsPerCycle </span></h3>
<p><b> Description </b>
</p><p>Defines how many quads (2x2 fragments) are generated, received, processed and sent per cycle at different stages of the fragment pipeline.
</p><p>For Triangle Traversal and Hierarchical Z the parameter represents how many generation tiles (size of the generation tile defined by the GenWidth and GenHeight parameters) are generated, received and processed per cycle.
</p><p>From Hierarchical Z to Fragment FIFO and the rest of fragment processing units (Interpolator, Z Stencil Test and Color Write) the parameter defines the total number of fragment quads that can be received/processed/sent per cycle.  The total fragment quad throughput is evenly distributed between the ROP instances (number defined by the NumStampPipes parameter in the GPU section).
</p><p>The value assigned to this parameter must be a multiple of the number of ROPs as defined by the NumStampPipes parameter in the GPU section.
</p><p>This parameter limits the maximum fragment quad throughput through the pipeline.
</p><p>The usual value for this parameter is 4 as the one used for NumStampPipes parameter.  Normal configurations should match both parameters.
</p><p>In future implementations this parameter may be removed or spawned into multiple parameters for different stages.  Z Stencil Test and Color Write already have their own parameter but right now it must match (taking account the number of instances) the value assigned to this parameter.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="MSAASamplesCycle"> MSAASamplesCycle </span></h3>
<p><b> Description </b>
</p><p>Defines how many MSAA samples per fragment generated or processed along the fragment pipeline per cycle can be generated or processed per cycle.  So if a value of 2 is assigned it means that for each fragment that can processed per cycle at any stage of the fragment pipeline 2 samples for the fragment can be processed per cycle.  If the number of samples associated with a fragment is higher than the value assigned to the parameter the stage will loop over the same fragment and take as many cycles as required to fully process the fragment at the configured sample processing rate.
</p><p>This parameter limits the fragment quad throughput of the fragment pipeline.
</p><p>In the current implementation the sample processing limitation is only implemented in the Triangle Traversal stage.  Z Stencil Test and Color Write are limited to process one sample per cycle.
</p><p>Usual values for this parameter are 2 or 4 samples per fragment.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="OverScanWidth"> OverScanWidth </span></h3>
<p><b> Description </b>
</p><p>Defines the width of an over scan tile as a number of scan tile.
</p><p>The fragments in a frame are organized in a hierarchy of tiles:
</p><p>fragment -&gt; quad (2x2) -&gt; gen tile -&gt; scan tile -&gt; over scan tile
</p><p>In the current implementation the over scan tile is not associated with any architectural parameter (like memory row size) or used for work distribution.
</p><p>In the current implementation only square tiles are likely to work (same width and height).
</p><p>The usual value for this parameter is 4.  Other values have not been tested so they may not work.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="OverScanHeight"> OverScanHeight </span></h3>
<p><b> Description </b>
</p><p>Defines the height of an over scan tile as a number of scan tile. 
</p><p>The fragments in a frame are organized in a hierarchy of tiles: 
</p><p>fragment -&gt; quad (2x2) -&gt; gen tile -&gt; scan tile -&gt; over scan tile 
</p><p>In the current implementation the over scan tile is not associated with any architectural parameter (like memory row size) or used for work distribution. 
</p><p>In the current implementation only square tiles are likely to work (same width and height).
</p><p>The usual value for this parameter is 4.  Other values have not been tested so they may not work.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ScanWidth"> ScanWidth </span></h3>
<p><b> Description </b>
</p><p>Defines the width of a scan tile as a number of fragments.
</p><p>The fragments in a frame are organized in a hierarchy of tiles: 
</p><p>fragment -&gt; quad (2x2) -&gt; gen tile -&gt; scan tile -&gt; over scan tile
</p><p>The scan tile defines the size of the scan step for the scan based rasterization algorithm.  The width of a scan tile must be a multiple of the width of a gen tile (defined by the GenWidth parameter).
</p><p>The scan tile is the work unit used to distribute fragment quads between the ROP instances and the shader processors. Some implementations would also try to associate the memory footprint of a scan tile to a single memory channel (or group of memory channels) to improve memory access locality.  Note that in the current implementation the footprint will increase when multiple samples are supported per fragment and the memory mapping function doesn't helps to distribute this increased footprint to the memory channels.
</p><p>The current implementation is likely to require square tiles (same width and height).
</p><p>The usual value for this parameter is 16.  Other values may not work.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ScanHeight"> ScanHeight </span></h3>
<p><b> Description </b>
</p><p>Defines the height of a scan tile as a number of fragments. 
</p><p>The fragments in a frame are organized in a hierarchy of tiles: 
</p><p>fragment -&gt; quad (2x2) -&gt; gen tile -&gt; scan tile -&gt; over scan tile 
</p><p>The scan tile defines the size of the scan step for the scan based rasterization algorithm.  The height of a scan tile must be a multiple of the height of a gen tile (defined by the GenHeight parameter).
</p><p>The scan tile is the work unit used to distribute fragment quads between the ROP instances and the shader processors. Some implementations would also try to associate the memory footprint of a scan tile to a single memory channel (or group of memory channels) to improve memory access locality.  Note that in the current implementation the footprint will increase when multiple samples are supported per fragment and the memory mapping function doesn't helps to distribute this increased footprint to the memory channels.
</p><p>The current implementation is likely to require square tiles (same width and height). 
</p><p>The usual value for this parameter is 16. Other values may not work.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="GenWidth"> GenWidth </span></h3>
<p><b> Description </b>
</p><p>Defines the width in fragments of a gen (generation) tile.
</p><p>The fragments in a frame are organized in a hierarchy of tiles: 
</p><p>fragment -&gt; quad (2x2) -&gt; gen tile -&gt; scan tile -&gt; over scan tile
</p><p>The gen tile defines the unit output of the Triangle Traversal (Fragment Generation) stage.  It's also used as the work unit for the Hierarchical Z stage.
</p><p>In the current implementation the memory footprint of a gen tile should match the cache line size for the Z and Color Cache (or be a multiple of the size when multiple samples per fragment are present).  It should also corresponds with the granurality of the Hierarchical Z buffer (1 element in the HZ Buffer corresponds with a gen tile).
</p><p>In the current implementation only squared tiles (same width and height) are likely to work.
</p><p>The usual value for this parameter is 8.  Other values won't work.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="GenHeight"> GenHeight </span></h3>
<p><b> Description </b>
</p><p>Defines the height in fragments of a gen (generation) tile. 
</p><p>The fragments in a frame are organized in a hierarchy of tiles: 
</p><p>fragment -&gt; quad (2x2) -&gt; gen tile -&gt; scan tile -&gt; over scan tile
</p><p>The gen tile defines the unit output of the Triangle Traversal (Fragment Generation) stage. It's also used as the work unit for the Hierarchical Z stage. 
</p><p>In the current implementation the memory footprint of a gen tile should match the cache line size for the Z and Color Cache (or be a multiple of the size when multiple samples per fragment are present). It should also corresponds with the granurality of the Hierarchical Z buffer (1 element in the HZ Buffer corresponds with a gen tile). 
</p><p>In the current implementation only squared tiles (same width and height) are likely to work. 
</p><p>The usual value for this parameter is 8. Other values won't work.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="RasterizationBatchSize"> RasterizationBatchSize </span></h3>
<p><b> Description </b>
</p><p>Defines the number of triangles that are processed in parallel when using the recursive rasterization algorithm at the Triangle Traversal (Fragment Generation) stage.  The equations for the triangles forming a batch of the size defined by this parameter are evaluated recursively at different tile sizes in parallel to generate fragments.  When the lower tile level is reached (scan tile) gen tiles worth of fragments are generated iteratively for each of the triangles being processed.
</p><p>The value for this parameter shouldn't be a large number to the large number of ALUs required to evaluate the triangle edge equations at each level of the tile hierarchy.
</p><p>The usual values for this parameter should be 2 or 4 triangles.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BatchQueueSize"> BatchQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of a buffer (FIFO) in Triangle Traversal (Fragment Generation) where triangles obtained from Triangle Setup are stored until they can be processed.  When the recursive rasterization algorithm is enabled groups of triangles (number defined by the RasterizationBatchSize parameter) are fetched from this buffer and initiate the traversal stage.
</p><p>The value assigned to this parameter must be a multiple of the value assigned to the TrianglesCycle parameter (triangle throughput).
</p><p>The value assigned to this parameter should be a mutiple of the value assigned to the RasterizationBatchSize parameter.
</p><p>In our current configuration files the value of this parameter is 16 triangles.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="RecursiveMode"> RecursiveMode </span></h3>
<p><b> Description </b>
</p><p>Enables the recursive rasterization algorithm in the Triangle Traversal (Fragment Generation) stage.  When the parameter is enabled recursive rasterization is used and the RasterizationBatchSize must be set to a number equal or greater than 1.  When the parameter is disabled a scan based traversal rasterization algorithm is used.
</p><p>In our current simulation files the recursive rasterization rasterization is used.  However the scan based rasterization algorithm should also work correctly.  Differences in performance may be due to overheads in the recursive algorithm, different order in which fragments are generated (in the recursive algorithm multiple triangles may be traversed at the same time), etc.
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h2> <span class="mw-headline" id="Micropolygon_rasterization_parameters"> Micropolygon rasterization parameters </span></h2>
<h3> <span class="mw-headline" id="UseMicroPolygonRasterizer"> UseMicroPolygonRasterizer </span></h3>
<h3> <span class="mw-headline" id="TriangleBoundOutputLatency"> TriangleBoundOutputLatency </span></h3>
<h3> <span class="mw-headline" id="TriangleBoundOpLatency"> TriangleBoundOpLatency </span></h3>
<h3> <span class="mw-headline" id="LargeTriangleFIFOSize"> LargeTriangleFIFOSize </span></h3>
<h3> <span class="mw-headline" id="MicroTriangleFIFOSize"> MicroTriangleFIFOSize </span></h3>
<h3> <span class="mw-headline" id="BypassStampFIFOSize"> BypassStampFIFOSize </span></h3>
<h3> <span class="mw-headline" id="MicroTriangleBypass"> MicroTriangleBypass </span></h3>
<h3> <span class="mw-headline" id="BypassMode"> BypassMode </span></h3>
<h3> <span class="mw-headline" id="DumpTriangleBurstSizeHistogram"> DumpTriangleBurstSizeHistogram </span></h3>
<h2> <span class="mw-headline" id="Hierarchical_Z_parameters"> Hierarchical Z parameters </span></h2>
<h3> <span class="mw-headline" id="DisableHZ"> DisableHZ </span></h3>
<p><b> Description </b>
</p><p>When the value of this parameter is TRUE the parameter disables the test at the Hierarchical Z stage of the fragment pipeline.
</p><p>For performance reasons this parameter should always be set to FALSE.
</p><p>Hierarchical Z test requires compression to be enabled at the Z caches.  So if compression is disabled the value of this parameter should be TRUE.  That's the actual common use for the parameter, prevent test at the Hierarchical Z in architectures defined with no Z compression.
</p><p>The usual value for this parameter is FALSE (test at Hierarchical Z stage enabled).
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="StampsPerHZBlock"> StampsPerHZBlock </span></h3>
<p><b> Description </b>
</p><p>Defines how many fragment quads (2x2) correspond with a Hierarchical Z buffer block.  The number in this parameter should be the number of fragment quads in a gen tile (as defined by the GenWidth and GenHeight parameters).
</p><p>The value for this parameter should be 16.  Other values won't work in the current implementation.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="HierarchicalZBufferSize"> HierarchicalZBufferSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the Hierarchical Z buffer as a the number of elements, each element corresponding with a HZ block (each block corresponds with a gen tile or Z cache cache line), that can be stored in the HZ buffer.
</p><p>To compute the actual size of the Hierarchical Z buffer in bits multiply by the 
</p><p>This parameter limits the size of the frame buffer.  If a framebuffer larger than the limit defined by this parameter is used the current implementation will generate a panic or fail to work properly as it will try to access elements beyond the actual size of the buffer.  Notice that when multisampling is enabled a HZ block corresponds with the size of a gen tile in samples, not fragments, so the actual limit to the framebuffer size is in samples not fragments.
</p><p>The usual value is 262144 which allows for framebuffers up to 4096x4096 fragments/samples.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="HZCacheLines"> HZCacheLines  </span></h3>
<p><b> Configuration </b>
</p><p>Defines how many lines has the cache used to access the Hierarchical Z buffer.
</p><p>As the Hierarchical Z buffer is a very large on die structure (&gt; 128 KBs) to reduce the latency of the access a small cache is implemente at the Hierarchical Z test stage to hold values read from the large Hierachical Z buffer.
</p><p>The performance effect of this parameter has not been evaluated.
</p><p>The usual value for this parameter is 8 lines.  
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="HZCacheLineSize"> HZCacheLineSize </span></h3>
<p><b> Description </b>
</p><p>Defines how many elements (HZ block reference value(s)) are stored per HZ cache line.  With the HZCacheLines parameter and the number of bits used to represent a HZ block/element defines the size of the HZ cache.
</p><p>The HZ cache is to reduce the latency when accessing the large on die Hierarchical Z buffer.
</p><p>The usual value for this parameter is 16 elements/blocks.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="EarlyZQueueSize"> EarlyZQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the queue (FIFO) which holds fragment quads received from the Triangle Traversal (Fragment Generation) stage and that are being tested against the Hierachical Z buffer.
</p><p>The current implementation uses a queue that holds fragment quads at all points of the HZ stage so it can be considered that the queue has multiple pointers and multiple read ports (aka incorrectly implemented/simulated).
</p><p>The size of the queue should at least match two times the bandwidth from the Triangle Traversal stage in terms of fragment quads (note that the bw is defined in terms of gen tiles in the configuration file).
</p><p>The performance effect of this queue has not been evaluated.
</p><p>The usual value for this parameter is 256 quads.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="HZAccessLatency"> HZAccessLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the latency in cycles for reading or writing a value from/to the Hierarchical Z buffer.  The access to the buffer is considered to be fully pipelined so an operation can be issued per cycle but will take the defined number of cycles to complete.
</p><p>The performance impact of this parameter has not been evaluated.
</p><p>In our current configuration files the value of this parameter is 5 cycles.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="HZUpdateLatency"> HZUpdateLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the latency in cycles for HZ block updates received from the Z caches.
</p><p>In the current implementation this parameter defines the latency of the signal between the Z Stencil Test boxes and the Hierarchical Z box that is used to send updates (on Z cache line eviction) for HZ blocks in the Hierarchical Z buffer.
</p><p>The performance impact of this parameter has not been evaluated.
</p><p>In our current configuration files the value of this parameter is 4 cycles.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="HZBlocksClearedPerCycle"> HZBlocksClearedPerCycle </span></h3>
<p><b> Description </b>
</p><p>Defines how many HZ elements/blocks in the Hierarchical Z buffer can be cleared (assigned to the default value: farthest Z) per cycle.
</p><p>When using fast z/stencil clear commands to clear and initialize the z and stencil buffer this parameter defines how fast the Hierarchical Z buffer can be cleared in parallel with the block state memory in the Z caches.
</p><p>The performance impact of this parameter has not been evaluated.
</p><p>In our current configuration files the value of the parameter is 256 blocks/elements.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h2> <span class="mw-headline" id="Interpolator_parameters"> Interpolator parameters </span></h2>
<h3> <span class="mw-headline" id="NumInterpolators"> NumInterpolators </span></h3>
<p><b> Description </b>
</p><p>Defines how many attributes (128 bits) can be interpolated per fragment processed per cycle by the attribute Interpolator stage.  As this is per fragment the actual number of attributes interpolated per cycles (and thus the number of interpolator ALUs required) is the value of this parameter multiplied by the value of the StampsCycle parameter and by 4 (number of fragments in a quad).
</p><p>The performance impact of this parameter has not been evaluated.
</p><p>In our current configuration files the value of the parameter is 4 attributes.  GPU architectures like the RV7xx family that implement attribute interpolation before shading like ATTILA the actual value is 1.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h2> <span class="mw-headline" id="Work_Distributor_.28FragmentFIFO.29_parameters"> Work Distributor (FragmentFIFO) parameters </span></h2>
<h3> <span class="mw-headline" id="ShaderInputQueueSize"> ShaderInputQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the queues (FIFO) that store shader elements to be issued to a shader processor.  There is one queue per shader processor and each queue has the size defined by the value assigned to this parameter.  Each entry in the queue represents a shader input.  The shader input queue receives shader inputs from other queues in Fragment FIFO (Shader Work Distributor) for all kind of tasks: vertices, triangles, fragments.
</p><p>The size of the queue must be at least 2 * numStampPipes multiplied by the size of the thread group in the legacy unified shader model or vector length in the vector shader model.
</p><p>The performance impact of this parameter has not been tested.
</p><p>In the current configuration files the size of this queue is 512 inputs.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ShaderOutputQueueSize"> ShaderOutputQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the queues (FIFO) used to receive shader outputs from the shader processors.  There is a queue per shader processor and the size of each queue is the value assigned to this parameter.  Each entry in the queue stores the data associated with a shader output.  From this queue the shader output is distributed in Fragment FIFO (Shader Work Distributor) to different units in the GPU depending on the shader output type: vertices, triangles, fragments.
</p><p>The size of the queue must be at least 2 * numStampPipes multiplied by the size of a thread group in the legacy shader model or the vector lenght in the vector shader model.
</p><p>The performance impact of this parameter has not been evaluated.
</p><p>In the current configuration files the value assigned to this parameter is 512 shader outputs.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ShaderInputBatchSize"> ShaderInputBatchSize </span></h3>
<p><b> Description </b>
</p><p>Defines the number of consecutive fragments that are batched together to be sent to the same shader processor.  This batch size is used for the batch based distribution algorithm that distributes fragments between the different shader processors.  The batch based distribution algorithm is used when the TiledShaderDistribution parameter is set to FALSE.  When using the batch based distribution algorithm the fragments are distributed between the shader processors based on the order they are generated by the Triangle Traversal (Fragment Generation stage) rather than based on the fragment position in the framebuffer used for the tiled distribution algorithm.
</p><p>The value assigned to this parameter must be a multiple of the value assigned to the ThreadGroup parameter (FRAGMENTSHADER section) for the legacy shader model or the VectorLenght parameter for the Vector Shader model.
</p><p>The batch based distribution algorithm for fragment to be processed in the shader processors has not been tested in years so it may not work.
</p><p>The value assigned to this parameter in our current configuration files is 64 fragments.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TiledShaderDistribution"> TiledShaderDistribution </span></h3>
<p><b> Description </b>
</p><p>Defines the algorithm used to distribute the fragments generated by the Triangle Traversal (Fragment Generation) stage between the shader processors.
</p><p>When the parameter is set to TRUE the fragments are distributed based on their position in the framebuffer.  In the current implementation all the fragments inside a scan tile (size defined by the ScanWidth and ScanHeight parameters) are issued to the same shader processor.  Each scan tile in on its own assigned to a different shader processor using a suitable distribution algorithm (Morton order, checkerboard, interleaved) based on its position on the framebuffer.  The distribution should try to avoid a single shader processor receiving most of the generated fragments and becoming the bottleneck of the GPU.
</p><p>When the parameter is set to FALSE the fragments are distributed based on the order they were generated by the Triangle Traversal (Fragment Generation) stage.  A number of consecutive fragments (defined by the ShaderInputBatchSize parameter) are send as a group/batch to the same shader processors, and the next batch will be sent to the next available shader processors.  Batching the fragments is required to keep access locality to the textures as each shader processor is assigned to its own Texture Unit.
</p><p>The usual value for this parameter is TRUE.  The batch based distribution algorithm has not been tested in years so it may not work.
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="VertexInputQueueSize"> VertexInputQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that is used to store vertices pending from being processed by the shader processors that have been received from the Streamer Loader unit.  From this queue groups of vertices (defined by the ThreadGroup or VectorLength parameters in the FRAGMENTSHADER section) are issued to a shader input queue assigned to a shader processor.  The vertices in this buffer are issued to the shader input queues.
</p><p>This parameter is not used by the legacy non-unified shader model.
</p><p>The value assigned to this parameter must be at least the number of elements in a ThreadGroup or VectorLength (FRAGMENTSHADER section), for legacy shader model or Vector Shader model, plus two times the vertex issue rate defined by the NumVertexShaders parameter (GPU section).
</p><p>The effect on performance of this parameter has not been evaluated.
</p><p>In our current configuration files the value of this parameter is 128 vertices.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ShadedVertexQueueSize"> ShadedVertexQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the reorder buffer (FIFO) that stores vertices that are being processed by the shader processors or have finished processing and are pending from being sent to Streamer Commit.  This buffer receives the shaded vertices from the shader output queues.
</p><p>This parameter is not used by the legacy non unified shader model architecture.
</p><p>The value assigned to this parameter must be at least the value assigned to the ThreadGroup, for legacy shader model, or Vector Length, Vector Shader model, parameters (FRAGMENTSHADER section).
</p><p>In the current implementation as the parameter defines a reorder buffer for all vertices being processed and there is no backpressure mechanism with the shader processors the value assigned limits the actual number of vertices that can be on the shader processors at any time.  Note that in the current implementation this parameter and the OutputFIFOSize and OutputMemorySize parameters (STREAMER section) represent redundant structures.  The parameter with the smaller value will be the one actually limiting the level of vertex parallelism in the shader processors.  For this reason it's recommendable to assign the same value to all three parameters.  It's reasonable though to assign a slightly higher value to OutputFIFOSize to account for vertices pending to be sent to the Primitive Assembly stage.
</p><p>The usual value assigned to this parameter is 512 vertices.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TriangleInputQueueSize"> TriangleInputQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) used to hold triangles that have been received from the Triangle Setup stage and are pending from being processed in the shader processors.  The triangles are stored in this buffer before being assigned to one of the shader input queues.  This buffer is only used when triangle setup on the shader is enabled by setting the TriangleSetupOnShader parameter to TRUE.
</p><p>The value assigned to this parameter must be equal or greater than the following sum:
</p>
<pre>ThreadGroup/VectorLength + (1 + SetupLatency) * TrianglesCycle
</pre>
<p>Where ThreadGroup or VectorLength (FRAGMENTSHADER section) define the minimum work that can be issued to a shader processor and the SetupLatency and TrianglesCycle define the latency and throughput from/of the Triangle Setup stage.
</p><p>This parameter is not used by the legacy non unified shader architecture.
</p><p>Triangle setup on the shader has not been used in years so it may not work.
</p><p>In our current configuration files the value assigned to this parameter is 32 triangles.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TriangleOutputQueueSize"> TriangleOutputQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the reorder buffer (FIFO) used for triangles that are being processed in the shader processors or that finished processing are pending from being returned to the Triangle Setup stage.  This buffer receives triangles from the shader output queues in Fragment FIFO (Shader Work Distributor).
</p><p>In the current implementation there is no backpressure mechanism with the shader processors so value assigned to this parameter limits the number of triangles that can be on the shader processors at any time.  This parameter and the TriangleShaderQueueSize parameter represent redundant structures though TriangleShaderQueueSize could be set to a slightly higher value to account for triangles already fully processed at Triangle Setup stage and waiting to be issued to the Triangle Traversal (Fragment Generation) stage.
</p><p>The value assigned to this parameter must be at least the value assigned to ThreadGroup, legacy shader model, or VectorLength, Vector Shader model (FRAGMENTSHADER section).
</p><p>The value assigned to this parameter must be equal or greater than:
</p>
<pre>(1 + SetupLatency) * TrianglesCycle)
</pre>
<p>Triangle setup on the shader has not been used in years so it may not work.
</p><p>In our current configuration files the value of this parameter is 32 triangles.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="GeneratedStampQueueSize"> GeneratedStampQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffers (FIFO) that store fragment quads (2x2 fragments) received from the Hierarchical Z.  There is one queue per ROP pipeline so the actual number of fragments stored in the buffers has to be multiplied by the number of ROP pipelines as defined by the NumStampPipes parameter (GPU section).  Quads stored in these buffers are sent to either the Interpolator stage that precedes shader processing (late Z) or to the Z Stencil Test ROPs (early Z).  
</p><p>The effect on performance of this parameter has not been evaluated.
</p><p>An usual value for this parameter is 256 fragment quads.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="EarlyZTestedStampQueueSize"> EarlyZTestedStampQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffers (FIFO) that store fragment quads (2x2 fragments) that have been processed in the Z Stencil Test stage.  There is a buffer per ROP pipeline so the total number of fragments hold on these buffers is obtained by multiplying by the number of ROP pipelines as defined by the NumStampPipes parameter (GPU section).  From these buffers fragments are issued to the Interpolator stage preceding shading (early Z) or to the Color Write stage (late Z).
</p><p>The performance effect of this parameter has not been evaluated.
</p><p>An usual value for this parameter is 32 fragment quads.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="InterpolatedStampQueueSize"> InterpolatedStampQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffers (FIFO) that store fragment quads that have been processed in the Interpolator stage and therefore have their input fragments attributes (128 bits) computed from their corresponding triangle vertex output attributes.  There is a buffer per ROP pipeline so the total number of fragments (with attributes) stored in these buffers is obtained by multipling by the number of ROP pipelines defined by the NumStampPipes parameter (GPU section).  The quads in the buffers wait until they can be issued to the shader input queues for shader processing.
</p><p>In the current implementation the number of fragments that the buffer can store is not affected by the actual number of input attributes defined for the fragments (up to 16).
</p><p>The value assigned to this parameter must be at least equal to the thread group or vector length defined in the FRAGMENTSHADER section.
</p><p>The performance effect of this parameter has not been evaluated.
</p><p>An usual value for the parameter is 32 quads.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ShadedStampQueueSize"> ShadedStampQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the reorder buffer (FIFO) for fragment quads that are being processed in the shaders or have finished processing are waiting to be issued to the Color Write stage (early Z) or the Z Stencil Test stage (late Z).  There is a buffer per ROP pipeline so the total number of fragments that can be on the shader processors combined with those that already finished shading are waiting to be issued to the next stage is obtained by multiplying by the number of ROP pipelines defined by the NumStampPipes (GPU section).
</p><p>In the current implementation as a shader output reorder queue and with no backpressure mechanism implemented with the shader processors the value assigned to this parameter limits the actual number of fragments that can be on a shader processor at any time.  For this reason the combined size of all the shaded quad buffers should be slightly larger than the combined number of shader elements supported per shader processor as defined by the ExecutableThreads parameter, for legacy shader model, or VectorThreads * VectorLength parameters, for Vector Shader model (FRAGMENTSHADER section).
</p><p>An usual value for this parameter is 2048 fragment quads (when combined with ExecutableThreads set to 8192 or VectorThreads set to 128 and VectorLenght set to 64).
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h1> <span class="mw-headline" id="FRAGMENTSHADER_section"> FRAGMENTSHADER section </span></h1>
<h2> <span class="mw-headline" id="Common_Shader_parameters"> Common Shader parameters </span></h2>
<p>Parameters used by the legacy shader model and the Vector Shader model.
</p><p><br>
</p>
<h3> <span class="mw-headline" id="VertexAttributeLoadFromShader"> VertexAttributeLoadFromShader </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE vertex attribute load is performed explicitly in the shader program using the LDA (load attribute) shader instruction and the Streamer Loader is configured in bypass mode so that only the index associated with the vertex is passed down to the shader processors.  Shader program translation in the driver must be enabled using the EnableDriverShaderTranslation parameter (SIMULATOR section).
</p><p>Enabling vertex attribute load from the shader will likely reduce performance as the number of instructions per vertex shader program increases and parallelism between the Streamer Loader stage and the shader processors is prevented.  For special workloads that require a high vertex or triangle throughput evaluating the performance of this configuration, and compared with implementing multiple instances of the Streamer Loader, would be interesting.  For now this option has received limited testing just to prove its correct functionality.
</p><p>Vertex attribute load from the shader is not possible with the legacy non unified shader architecture as a vector shader processor is not connected to a Texture Unit.
</p><p>The usual value for this parameter is FALSE.
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p><p><br>
</p>
<h3> <span class="mw-headline" id="SwapOnBlock"> SwapOnBlock </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE the thread group or vector thread that is currently active in the fetch stage will only be replaced (thread swap/switch) with another ready thread group or vector thread when the current thread group or vector thread is blocked, either due to a texture operation, an explicit wait point or the end of the thread.
</p><p>When this parameter is set to FALSE a thread group or vector thread only remains active in the fetch stage for a single fetch operation (number of instructions fetches depends on the value of the FetchRate parameter).  The next cycle a new thread group or vector thread will become active in the fetch stage.  The mechanism used for the selection of the next thread group or vector thread depends on the value ThreadWindow parameter.
</p><p>Evaluation of the performance effect of this parameter is planned as a future research topic.
</p><p>In our current configuration files this parameter is set to FALSE.
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="FixedLatencyALU"> FixedLatencyALU </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE all the shader instructions take the same fixed number of cycles to execute through the ALUs.  In the current implementation this fixed execution latency is set to 4 but may change or be configurable in future implementations.
</p><p>When this parameter is set to FALSE the execution latency of a shader instruction will depend on the opcode of the instruction.  Some instructions may require just one cycle through the ALUs while other may require up to 9 cycles (for example reciprocate or reciprocate square root operations).
</p><p>The actual execution latency and repeat rate latency for shader instructions is currently implemented per opcode tables in the ShaderArchitectureParameters class.  This parameter is used to select between two sets of tables: fixed latency (FixLat) and variable latency (VarLat).  For the vector shader architecture it also exist a fixed latency and variable latency table sets for the SOA (scalar) ALU architecture.  Future implementations may replace the current parameter for one that explicitely selects a table set using a predefined name for example "FixedLatAOS".
</p><p>Performance effect of this parameter may be evaluated in the future.
</p><p>In our current configuration this parameter is set to FALSE.
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="InputsPerCycle"> InputsPerCycle </span></h3>
<p><b> Description </b>
</p><p>Defines how many shader elements can be received per cycle from the Fragment FIFO (Shader Work Distributor) stage.  The shader elements or shader inputs can be of any of the currently supported types: vertices, triangles, fragments.
</p><p>The value assigned to this parameter shouldn't be a bottleneck so the combined bandwidth from FragmentFIFO to the shader processors should at least match the maximum throughput of the rest of the GPU pipeline usually defined by the fragment pipeline which uses to be limited by the ROP throoughput.
</p><p>The current implementation doesn't takes into account the number of active input attributes to the shader element to reduce the actual bandwidth.
</p><p>An usual value for this parameter is 4 shader elements per cycle.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="OutputsPerCycle"> OutputsPerCycle </span></h3>
<p><b> Description </b>
</p><p>Defines the number of shader elements that can be sent back to the Fragment FIFO (Shader Work Distributor) stage per cycle.  The value assigned to this parameter is actually the maximum throughput of the shader processor.
</p><p>The current implementation decreases the bandwidth with Fragment FIFO based on the number of active output attributes associated with the shader elements/outputs.  The bandwidth decrease is based on constants defined in the shader simulation classes.  The current implementation for example may provide enough bandwidth for 2 attributes (2x128 bits) per shader element.
</p><p>The value assigned to this parameter shouldn't, usually, become the bottleneck of the GPU.  For this reason the combined throughput from the shader processors to the Fragment FIFO (Shader Work Distributor) stage should at least match the throughput of the ROP pipelines, which is usually the maximum rate at which shader outputs can be consumed by the GPU pipeline.
</p><p>An usual value for this parameter is 4 shader elements/outputs.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="OutputLatency"> OutputLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the maximum latency in cycles for sending shader elements back to the Fragment FIFO (Shader Work Distributor) stage.
</p><p>In the current implementation the actual latency depends on the number of active output attributes associated with a shader element.  The actual latency is computed using defined constants in the shader simulation classes.
</p><p>Performance effect of this parameter has not been evaluated.
</p><p>In our current configuration files the value for this parameter is 11 cycles which correspond with 3 minimum cycles and up to 8 cycles, one cycle for each two active attributes for a maximum of 16 output attributes.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureUnits"> TextureUnits </span></h3>
<p><b> Description </b>
</p><p>Defines the number of Texture Units that are attached to a shader processor.
</p><p>In the current implementation a Texture Unit can only be attached to a single shader processor but a shader processor may have multiple Texture Units attached.
</p><p>The ALUs configured for the shader processor by the ThreadRate parameter for the legacy shader model or VectorALUWidth for the vector shader model and the value of this parameter define the ALU to texture ratio of the simulated architecture.  The ALU to texture ratio is a key element that affects the performance of the simulated architecture.  GPU architectures with a high ALU to texture ratio may become texture limited while GPU architectures with a low ALU texture ratio may suffer from underutilization of the Texture Unit in modern shading dominated games.
</p><p>The usual value for this parameter is one Texture Unit per shader processor but higher values are possible when ThreadRate or VectorALUWidth are set to values larger than 4 and the simulated architecture requires a low ALU to texture ratio.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureRequestRate"> TextureRequestRate </span></h3>
<p><b> Description </b>
</p><p>Defines how many texture requests (one texture request for 4 shader elements) can be issued and received per cycle from/to the Texture Units attached to shader processor.  Note that the value is the aggregated throughput with the all the Texture Units.
</p><p>The value assigned to this parameter limits the throughput of the Texture Units.
</p><p>The usual value for this parameter is 1 or if more than one Texture Unit is attached to the shader processor the number of Texture Units attached.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureRequestGroup"> TextureRequestGroup </span></h3>
<p><b> Description </b>
</p><p>Defines the number of consecutive texture requests (one texture requests per 4 shader elements) are issued to the same Texture Unit.  After the defined number of texture requests are issued the next batch of consecutive texture requests will be issued to the next available Texture Unit. 
</p><p>This parameter is only useful when more than one Texture Unit is attached to the shader processor.  The purpose of this parameter is to batch together a relatively large number of requests to improve the locality of texture accesses.
</p><p>In our current configuration files this parameter is set to 64 texture requests.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h2> <span class="mw-headline" id="Legacy_Shader_parameters"> Legacy Shader parameters </span></h2>
<p>Parameters that are only used by the legacy shader model.
</p><p><br>
</p>
<h3> <span class="mw-headline" id="ExecutableThreads"> ExecutableThreads </span></h3>
<p><b> Description </b>
</p><p>Defines, for the legacy shader model, how many threads or shader elements can be executable at any time in the shader processors.
</p><p>The value assigned to this parameter must be a multiple of the value assigned to ThreadGroup.
</p><p>The value of this parameter divided by the value of the ThreadRate defines the maximum latency for texture operations that the shader processor can hide.  However this maximum value is reduced by resource limitations and threads that may not be in an executable state.
</p><p>The value of this parameter affects the optimum value for the ShadedStampQueueSize parameter (RASTERIZATION section).
</p><p>In our current configuration files the value assigned to this parameter is 8192 shader threads/elements.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="InputBuffers"> InputBuffers </span></h3>
<p><b> Description </b>
</p><p>For some reason in the first implementation of the shader processor model there was a difference between storage for shader elements (vertices or fragments) that were being received from the producer unit (Streamer or FragmentFIFO) and storage and state for actual runnable threads for shader elements. This parameter represents how much storage is used for those elements that are being loaded but can not execute until a free runnable thread is available. 
</p><p>The value assigned to this parameter must be a multiple of the value defined for the ThreadGroup parameter.  Large values are not required.
</p><p>The value in our current configuration files is 128 (2x64 for ThreadGroup set to 64).
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ThreadResources"> ThreadResources </span></h3>
<p><b> Description </b>
</p><p>In the current implementation resources mean registers to store temporal data for the shader elements. At some point a resource represented two registers allocated as a pair but I think it was changed later to represent a single register (128 bits). The actual meaning is mainly controlled by the API/driver implementation which is the one that decides how many resources requires a shader program to execute. The shader processor logic also takes into account the number of input or output attributes defined with the shader program to compute the resources to reserve per shader element. 
</p><p>The value represents the total number of resources for each instance of the shader processor. Each shader thread (actually an element) has to reserve the required amount of resources before it can start executing. 
</p><p>The value limits how many shader threads/elements can be in execution at any point and depends on the loaded shader program. 
</p><p>The value assigned to this parameter must be equal or greater than the value assigned to the ExecutableThreads parameter. At least a resource per thread is required or the actual number of executable threads would never be reached. 
</p><p>In our current configuration files the value for this parameter is 16384 or two times the number of executable shader threads/elements as defined in the ExecutableThreads parameter.  Two registers per fragment shader element is a reasonable minimum to keep enough executable threads/elements for texture operation latency hiding after resource allocationg.  And 16384 registers is more than enough for vertex processing.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ThreadRate"> ThreadRate </span></h3>
<h3> <span class="mw-headline" id="ThreadWindow"> ThreadWindow </span></h3>
<p><b> Description </b>
</p><p>Defines which group of shader elements (a thread group as defined by the ThreadGroup parameter)  will selected as the next fetch group and start the fetch and execution of instructions for the group.
</p><p>When the parameter is set to TRUE a thread/group window tracks the state of the different thread groups and selects out of order (using a round robin priority) a ready thread for fetch and execution.  Groups that are not ready due to be waiting for memory (Texture Unit) are never selected and the fetch stage will only stall if there are no ready groups in the thread window.
</p><p>When the parameter is set to FALSE all groups are in a FIFO and the group at the head of the FIFO is the one that is selected in order for fetch and execution.  If the group is not ready the fetch stage is stalled until the groups becomes ready.
</p><p>The usual value for this parameter is TRUE.  FIFO based group selection has not been tested in a while so it may not work correctly.
</p><p><br>
<b> Format </b> 
</p><p>Boolean (TRUE/FALSE)
</p><p><br>
</p>
<h3> <span class="mw-headline" id="FetchDelay"> FetchDelay </span></h3>
<p><b> Description </b>
</p><p>Defines the minimum number of cycles between instructions fetches for thread groups in the legacy shader model.  The fetch stage will wait the configured number of cycles before attempting to fetch an instruction from the current or next (depending on the thread scheduling configuration) thread group.
</p><p>If the defined size of a thread group (ThreadGroup parameter) is higher than the number of available ALUs the fetch logic will already delay the next fetch for as many cycles as iterations are required to fully run the thread group through the available ALUs.  The limit defined by this parameter is applied as a minimum on top of the previous limitation so in cases that the thread group would require a single iteration the fetch logic would still stall for the defined number of cycles before fetching instructions for the current or next thread group.
</p><p>When the groups to fetch are selected from a FIFO (ThreadWindow parameter set to FALSE) this parameter should be set to a value greater than 0 and equal or greater than the number of iterations required to fully run a thread group through the ALUs.  This is necessary to avoid desynchronization of the PC for the groups in the FIFO due to the decode stage issuing 'repeat last instruction' commands.
</p><p>The usual value for this parameter in our configuration files is 4 cycles (thread groups require four iterations through the fetch stage and ALUs).
</p><p><b> Format </b>
</p><p>Integer
</p><p><br>
</p>
<h3> <span class="mw-headline" id="FetchRate"> FetchRate </span></h3>
<p><b> Description </b>
</p><p>Defines the number of SIMD4 operations that each ALU in the shader processor can execute per cycle.  The operations are for the same shader thread/element so the parameter also defines how many consecutive instructions are fetched for each fetch operation (in a way similar to a superscalar processor or a VLIW processor).  The decode stage will prevent coupled instructions from the fetch stage to execute if it detects dependencies (most VLIW processors defer dependency checking to the compiler).
</p><p>Combined with the ScalarALU parameter when this parameter has a value of 2 it is used to specify a shader ALU configuration that supports one SIMD4 operation coupled with one scalar operation.  When the ScalarALU parameter is set to FALSE the ALU configuration will support as many SIMD4 in parallel as the value defined for this parameter.
</p><p>The usual value for this parameter is 2 and coupled with the ScalarALU parameter set to TRUE for a SIMD4+scalar ALU configuration.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ScalarALU"> ScalarALU </span></h3>
<p><b> Description </b>
</p><p>When combined with the FetchRate parameter set to 2 operations this parameter defines a ALU configuration that supports a SIMD4 operation and a scalar operation in the same cycle.
</p><p>When the value of this parameter is TRUE the FetchRate parameter must be set to 2.
</p><p>In our current configuration files the value of this parameter is TRUE.
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="ThreadGroup"> ThreadGroup </span></h3>
<p><b> Description </b>
</p><p>Defines how many shader threads/elements are ganged together as a single thread group that shares the thread state (ready, blocked, finished) and the program counter (PC).  When the  LockedExecutionMode parameter is set to TRUE all the threads/elements in the group execute the same instructions in lock step similar to how a vector architecture would execute instructions over the vector elements.
</p><p>In our current configuration files the value of this parameter is 64 shader threads/elements (similar the ATI/AMD R5xx to RV7xx architectures).
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="LockedExecutionMode"> LockedExecutionMode </span></h3>
<p><b> Description </b>
</p><p>In the old shader model this parameter defines if shader threads/elements in a group are executed in lock step. All the threads/elements in the group execute the same instruction(s) using a SIMD execution model and share the same thread information (PC, state). 
</p><p>For fragment shaders in the legacy non-unified shader architecture and for shader processors in the unified shader architecture this parameter should always be set to TRUE.  MIMD execution is not suited for fragment shading as at least lock step execution per fragment quad (2x2 fragments) is required to compute texture coordinate derivatives in the Texture Unit.
</p><p>In our current configuration files the value of this parameter is TURE.
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h2> <span class="mw-headline" id="Vector_Shader_parameters"> Vector Shader parameters </span></h2>
<p>Parameters used by the Vector Shader model.
</p><p><br>
</p>
<h3> <span class="mw-headline" id="VectorShader"> VectorShader </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE the Vector Shader model is used to simulate the shader processors.  The Vector Shader model is only supported for the unified shader architecture.
</p><p>When this parameter is set to FALSE the legacy shader model is used to simulate the shader processors or fragment shader processors for the legacy non unified shader architecture.
</p><p>The old shader model remains as legacy and for compatibility and validation.  The Vector Shader model will be the base for future research and development of the shader processors so in our current simulation files the value for this parameter is TRUE.
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="VectorThreads"> VectorThreads </span></h3>
<p><b> Description </b>
</p><p>Defines the number of threads supported in the vector shader processor.  Each thread is associated with a number of shader elements defined by the Vector Length parameter.  All the shader elements in the thread execute the same instructions in lock-step (as a normal vector architecture).  The value assigned to this parameter is the maximum number of threads supported by the vector shader processor, due to resource limitations or threads blocked waiting to memory the actual number of threads that are executable at some point in time may be significatively smaller.
</p><p>The value assigned to this parameter, multipled by the value of the VectorLength and divided by the VectorALUWidth determines the maximum number of memory access latency that the shader processor can hide (at least when the SwitchOnBlock and parameter is set to FALSE, otherwise it's just a good approximation).
</p><p>In our current configuration files the value of this parameter is 128 threads (similar to ATI/AMD R5xx-RV7xx GPUs).  Coupled with VectorLength set to 64 the total number of shader elements that can be on execution in the vector shader processor would be 8192.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="VectorResources"> VectorResources </span></h3>
<p><b> Description </b>
</p><p>Defines how many resources are available per vector thread.  When a vector thread is loaded in the vector shader processor it must allocate a number of resources based on the number of active input or output attributes for the shader element type and the temporal registers required by the shader program (value computed by the API/driver).  In the current implementation one resource represents one vector register (128-bit register x VectorLength elements).
</p><p>The value of this parameter limits how many vector threads are actually available for execution depending on the characteristics of the shader programs and shader elements of the different types that are in the vector shader processor.
</p><p>The value of this parameter must at least equal to the value of the VectorThreads parameter.  The minimum requirement is 1 resource/vector register per vector thread.
</p><p>In our current configuration files the value of this parameter is 512 or four vector registers per vector thread (with VectorThread set to 128).  This value should be similar to the registers per vector in the AMD RV7xx GPUs.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="VectorLength"> VectorLength </span></h3>
<p><b> Description </b>
</p><p>Defines the number of shader elements in a shader vector thread.  All the shader elements in a vector thread share the thread state (ready/blocked state, program counter, etc) and execute the same shader instructions in lock-step.
</p><p>The value of this parameter must be a multiple of the value assigned to the VectorALUWidth parameter.
</p><p>The value of this parameter must be a multiple of the values assigned to InputsPerCycle and OutputsPerCycle parameters.
</p><p>In our current configuration files the value of this parameter is 64 shader elements.  This value is similar to the vector length for the AMD R600 and RV770 GPUs.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="VectorALUWidth"> VectorALUWidth </span></h3>
<p><b> Description </b>
</p><p>Defines the number of ALUs in the vector ALU array of the vector shader processor.
</p><p>The value assigned to this parameter determines how many cycles are required to execute one instruction (or group of instructions for the SIMD4+scalar architecture) over all the elements in a vector thread.  The number of iterations required is computed by dividing the value of the VectorLength parameter by this value.  The value of the VectorLenght parameter must be a multiple of this value.  The fetch and decode stage will stall until all the elements in the vector thread have executed (started) the instruction.
</p><p>In our current configuration files the value of this parameter is 64 ALUs.  This value is the same the value of the ALU array in the shader processors for the AMD R600 and RV770 GPUs.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="VectorALUConfig"> VectorALUConfig </span></h3>
<p><b> Description </b>
</p><p>Defines the configuration of the per element ALU in the vector ALU array.
</p><p>The current implementation of the vector shader model supports the following ALU configurations:
</p>
<ul><li> "simd4" =&gt; Each ALU can execute one scalar or SIMD4 operation
</li></ul>
<ul><li> "simd4+scalar" =&gt; Each ALU can execute in parallel one scalar and one SIMD4 operation or two scalar operations (implemented by AMD R6xx - RV7xx GPUs)
</li></ul>
<ul><li> "scalar" =&gt; Each ALU can execute one scalar operation (SOA architecture, implemented in NVidia G8x, G9x and GT2xx GPUs and Intel Larrabee)
</li></ul>
<p>In the current implementation if the parameter is set to the "scalar" configuration the EnableDriverShaderTranslation parameter (SIMULATOR section) must also be set to TRUE.  The conversion from AOS (array-of-structs) shader programs (OGL ARB or D3D ISAs) to SOA (struct of arrays) is performed in the driver translation function.
</p><p>In our current configuration files the value of this parameter is set to "simd4+scalar".
</p><p><br>
<b> Format </b>
</p><p>String
</p>
<h3> <span class="mw-headline" id="VectorWaitOnStall"> VectorWaitOnStall </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE the decode stage will stall the vector shader processor if the next shader instruction to execute has a pending dependency with a previous instruction.  When multiple instructions are fetched as a group (VectorALUConfig parameter with value "simd4+scalar") only the first instruction (in program order) can actually stall the vector shader processor, if the other instruction has a pending dependency the decode stage will just send a message to the fetch stage to set back the program counter (PC) of the corresponding vector thread to the PC of the dependant instruction.
</p><p>When this parameter is set to FALSE the decode stage will never stall the vector shader processor.  When pending dependency is detected on a fetched instruction the instruction, and any other instruction following the instruction with the dependency if multiple instruction are fetched as a group (VectorALUConfig parameter with value "simd4+scalar"), will be dropped before the execution stage and the decode stage will send a message to the fetch stage to set back the program counter (PC) of the corresponding vector thread to the PC of the dependant instruction.
</p><p>The performance effect of this parameter will be evaluated in the future.
</p><p>In our current configuration files this parameter is set to FALSE.  The implementation of this feature is still in an experimental stage.
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="VectorExplicitBlock"> VectorExplicitBlock </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE a vector thread will only become blocked at shader instructions with the wait point flag set (explicit wait/blocking point).  The decode stage will check if there are pending requests to the Texture Units for the vector thread and will block the vector thread until all the pending requests have returned from the Texture Units.  When a vector thread issues the last instruction (end flag set) the vector ALU array the vector thread is also blocked as a temporal step before transitioning to the finished state.
</p><p>When this parameter is set to FALSE a vector thread will be blocked when a texture instruction is executed and won't be resumed until the corresponding texture request has not returned from the Texture Units.
</p><p>In the current implementation if this parameter is set to TRUE the EnableDriverShaderTranslation parameter (SIMULATOR section) must be set to TRUE as the explicit wait points for texture results are currently set by the driver shader translation function.
</p><p>The performance effect of this parameter will be evaluated in the future.
</p><p>In our current configuration files the parameter is set to FALSE.  The implementation of this parameter is feature is still in a experimental stage.
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h2> <span class="mw-headline" id="Texture_Unit_parameters"> Texture Unit parameters </span></h2>
<h3> <span class="mw-headline" id="AddressALULatency"> AddressALULatency </span></h3>
<p><b> Description </b>
</p><p>Defines the latency of cycles of the Texture Unit stage that converts texture coordinates into memory addresses.
</p><p>The computations performed by the Address ALU include:
</p>
<ul><li> level of detail computation
</li><li> anisotropic algorithm
</li><li> lod selection
</li><li> normalized space to texel space
</li><li> bilinear sample generation
</li><li> anisotropic sample generation
</li><li> bilinear, trilinear and anisotropic weights
</li><li> tiled memory (block, superblock)
</li></ul>
<p>In the current implementation the Address ALU can generate addresses for a bilinear sample (2x2 texels) for a fragment quad (2x2 fragments) in a single cycle.  When multiple bilinear samples are required (trilinear filtering, 3D textures or anisotropic filtering) the texture request will require multiple cycles through the address ALU, and therefore the throughput will be reduced.
</p><p>In our current simulation files the latency is set to 15 cycles.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="FilterALULatency"> FilterALULatency </span></h3>
<p><b> Description </b>
</p><p>Defines the latency in cycles of the Texture Unit Filter ALU.  The Filter ALU computes the bilinear sample result from the texels read from the Texture Cache and combines bilinear sample results for complex filter modes (trilinear filtering, 3D textures, anisotropic filtering).
</p><p>In the current implementation the Filter ALU can generate a bilinear sample result for a fragment quad (2x2 fragments) per cycle.  For texture requests with complex filter modes the request will iterate through the Filter ALU until all the corresponding bilinear sample results are computed so the throughput will be reduced.
</p><p>In out current configuration files the latency is set to 10 cycles.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="AnisotropyAlgorithm"> AnisotropyAlgorithm </span></h3>
<p><b> Description </b>
</p><p>Defines the implementation of the anisotropic algorithm that the Texture Unit will use.
</p><p>There are four implementations currently implemented:
</p>
<ul><li> 0&nbsp;: 'Two Axis' algorithm.  This algorithm is the basic anisotropic algorithm described in the OpenGL anisotropic extension.  The algorithm is based on detecting anisotropy on the X and Y framebuffer axis.  The shape resulting from this algorithm in the tunnel test shows four large petals at 45 degrees multiples.  This algorithm was implemented by the ATI R2xx GPUs and is implemented by the Intel GenX IGPs.
</li><li> 1&nbsp;: 'Four Axis' algorithm.  This algorithm extends the basic anisotropic algorithm by considering a 45 degree rotation of the X and Y framebuffer axis.  The shape resulting from this algorithm in the tunnel test shows eight thinner petals at 30 degrees multiples.  This algorithm has been implemented by ATI since the R3xx GPUs and NVidia since the NV3x GPUs and currently is the 'low quality/performance' method used by both AMD and NVidia GPUs.
</li><li> 2&nbsp;: 'Rectangular' algorithm.  An experimental algorithm trying to replicate current HQ algorithms implemented by AMD and NVidia.  The algorithm tries to detect anisotropy based on a rectangular approximation of the pixel projection on texture space along the X and Y and 45 degree rotated X and Y screen axis.  The shape resulting from this algorithm in the tunnel test shows a squarish approximation to a circle.
</li><li> 3&nbsp;: 'EWA' algorithm.  This algorithm is the 'perfect' anisotropic algorithm described in Heckbert's thesis.  The shape resulting from this algorithm in the tunnel test is a perfect circle.
</li><li> 4&nbsp;: 'Experimental' algorithm.  Another experimental algorithm trying to replicate current HQ algorithms implemented by AMD and NVidia.  The current implementation doesn't seem to be working properly.
</li></ul>
<p>In future implementations this parameter may be converted to string type.
</p><p>In our current configuration files this parameter is set to 3 (EWA, high quality).  However if the simulated traces are limited by texture filtering and depending on the objective of the experiments being performed it can be more reasonable to set the parameter to 1 (four axis, low quality/performance).
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ForceMaxAnisotropy"> ForceMaxAnisotropy </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE the maximum anisotropy defined by the MaxAnisotropy parameter is force for all texture requests.
</p><p>When this parameter is set to FALSE the anisotropy used for texture requests is the one computed by the selected anisotropic algorithm (AnisotropyAlgorithm parameter) clamped to the maximum anisotropy defined by the MaxAnisotropy parameter.
</p><p>The value of this parameter may affect the performance of the Texture Unit reducing or increasing the texture filtering workload of the application.
</p><p>In our current configuration files this parameter is set to FALSE.
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="MaxAnisotropy"> MaxAnisotropy </span></h3>
<p><b> Description </b>
</p><p>Defines the maximum anisotropy that the Texture Unit will apply.  This parameter defines the maximum supported anisotropic ratio or what is the same the maximum number of bilinear samples that can be requested.  All texture requests will be clamped to the defined maximum anisotropy.  When the ForceMaxAnisotropy is set all the texture requests (with anisotropic filtering enabled) will be force to request the defined maximum number of bilinear samples.
</p><p>The maximum anisotropy supported by the current implementation of the Texture Unit is 16 samples.  The computed anisotropic ratio will first be clamped to 16 (constant defined in GPU.h) and then clamped to the value defined by the parameter.  Values greater than 16 are not supported for this parameter.
</p><p>This parameter may be used to reduce (or even increase when combined with the ForceMaxAnisotropy parameter) the texture filtering workload of the simulated traces.
</p><p>In the current implementation this parameter is set to 16 samples.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TrilinearPrecision"> TrilinearPrecision </span></h3>
<p><b> Description </b>
</p><p>Defines the precision as number of bits used to compute the fractional part of the level of detail (lod) that is also used as a weight for combining the two bilinear sample results corresponding with a trilinear sample.
</p><p>In the current implementation trilinear weight computation is performed using 32-bit float point operations and later the resulting lod fraction is clamped to the specified precision.
</p><p>When the due to precision limitations the lod fraction becomes 0.0 or 1.0 only one bilinear sample from a single lod is taken.  The BrilinearThreshold parameter can be used to increase the range of fractional values for which only one bilinear sample is taken.
</p><p>In the current implementation the maximum value that can be used for this parameter is 32 bits.
</p><p>In our current configuration files this parameter is set to 8 bits.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BrilinearThreshold"> BrilinearThreshold </span></h3>
<p><b> Description </b>
</p><p>Defines the range of fractional lod values for which samples from two lods will be taken.
</p><p>The range for the given value is defines as:
</p>
<pre>[value / 2^prec .. 1.0 - value /2^prec]
</pre>
<p>Where 'value' is the value defined for this parameter and 'prec' is the precision in bits defined by the TrilinearPrecision parameter.
</p><p>If the value of this parameter is set to 0 then the full precision of the current implementation will be used (32-bit float point).
</p><p>The name 'brilinear' of the parameter comes from a performance optimization used by AMD and NVidia drivers that greatly reduce the range of lod fractional values for which true trilinear filtering is used.
</p><p>This parameter can be used to reduce the texture filtering workload of the simulated traces.
</p><p>The value of this parameter can not be greater than (2^prec - 1).
</p><p>In our current configuration files this parameter is set to 0.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="AnisoRoundPrecision"> AnisoRoundPrecision </span></h3>
<p><b> Description </b>
</p><p>Defines the precision, as a number of bits, used to compute and round the anisotropic ratio to the next valid anisotropic ratio value.
</p><p>In the current implementation the anisotropic ratio is computed using 32-bit float point operations.  The full precision is then clamped and rounded up based on the value of this parameter and the values of the AnisoRoundThreshold and AnisoRatioMultOfTwo parameters.
</p><p>This parameter affects the texture filtering workload by changing how many anisotropic samples are actually required for a texture request.
</p><p>In the current implementation the maximum value for this parameter is 32 bits.
</p><p>In our current configuration files this parameter is set to 8 bits.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="AnisoRoundThreshold"> AnisoRoundThreshold </span></h3>
<p><b> Description </b>
</p><p>Defines how the anisotropic ratio is rounded to the next valid anisotropic ratio value.
</p><p>If the AnisoRatioMultOfTwo parameter is set to FALSE the anisotropic ratio is rounded to the next integer anisotropic ratio value if the fractional ratio is greater than (value / 2^prec) where 'value' is the value of the parameter and prec is the precision defined by the AnisoRoundPrecision parameter.
</p><p>If the AnisoRatioMultOfTwo parameter is set to TRUE the anisotropic ratio is rounded to the next even integer anisotropic ratio value if the fractional ratio is greater than (2.0 * (value / 2^prec)) where 'value' is the value of the parameter and 'prec' is the precision defined by the AnisoRoundPrecision parameter.
</p><p>In the current implementation the anisotropic ratio is computed with 32-bit float point operations.  If the value of this parameter is 0 the full precision of the implementation is used and the anisotropic ratio is rounded to the nearest smaller integer.
</p><p>This parameter affects the texture filtering workload of the simulated traces.
</p><p>The value of this parameter can not be greater than (2^prec - 1) where 'prec' is the precision defined by the AnisoRoundPrecision parameter.
</p><p>In our current configuration files the value of this parameter is 0.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="AnisoRatioMultOfTwo"> AnisoRatioMultOfTwo </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE the final anisotropic ratio, and therefore the number of samples taken for a texture request with anisotropic filtering enabled, must be 1 or an even number.
</p><p>This parameter affects how the computed anisotropic ratio is rounded to the next valid anisotropic ratio value (see AnisoRoundThreshold parameter for details).
</p><p>This parameter affects the texture filtering workload of the simulated traces.
</p><p>In our current configuration files this parameter is set to FALSE.
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="TextureBlockDimension"> TextureBlockDimension </span></h3>
<p><b> Description </b>
</p><p>Defines the size in texels of the first level texture tiles.  Textures are stored in memory using tiles of the defined size to improve access locality.  The first level texture tile is a square tile with a size of 2^n x 2^n texels, where n is the value assigned to the parameter.
</p><p>The first level texture tile is related to the Texture Cache cache line size.
</p><p>In our current configuration files this parameter is set to 2 for a size of 4x4 texels (for 32-bit texture formats 64 bytes per cache line).
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureSuperBlockDimension"> TextureSuperBlockDimension </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the second level texture tiles in first level texture tiles.  Textures are stored in memory as tiles of tiles.  Each second level texture tile corresponds with 2^n x 2^n first level tiles, where n is the value assigned with this parameter.  The size of first level tiles in texels is defined by the TextureBlockDimension parameter.
</p><p>The second level texture tile size is related with the size of the texture cache.
</p><p>In our current configuration files this parameter is set to 4 for a size of 16x16 first level tiles (for 32 bit texture formats would corresponds with a 16 KB texture cache).
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureRequestQueueSize"> TextureRequestQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that holds texture requests received from the shader processors.  The texture requests are issued from this queue to the Address ALU stage of the Texture Unit.
</p><p>In the current implementation the size of this buffer should be large enough to hold all the possible pending requests that a shader processor would generate.  The reason is that shader processor doesn't has a mechanism to store texture requests for future issue and if the Texture Unit stops accepting new requests the shader threads may stall.
</p><p>The size of this buffer must be at least twice the number of texture requets that the shader processor can issue per cycle as defined by the TextureRequestRate parameter.
</p><p>In fact performance impact of this parameter or the current implementation has not been evaluated.
</p><p>In our current configuration files the value of this parameter is 512 texture requests (each request corresponds to a fragment quad).
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureAccessQueue"> TextureAccessQueue </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that holds texture requests being processed through the whole Texture Unit pipeline.
</p><p>In the current implementation the defined size acts as a global buffer for requests computing addresses (Address ALU), fetching data (Texture Cache), reading data (Texture Cache) or performing filtering (Filter ALU).  Given that the Texture Unit is a relatively large pipeline with reduced buffering between stages coupled with a very large buffer for memory latency hiding the main purpose of this buffer is to model the actual latency hiding capability of the Texture Unit.
</p><p>The actual performance effect of this parameter has not been evaluated.
</p><p>In our current configuration files the value of this parameter is set to 256 texture requests (each texture requests corresponds with a fragment quad).
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureResultQueue">TextureResultQueue </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that hold texture results pending to be send back to the corresponding shader processor.
</p><p>In the current implementation the size of this buffer doesn't has to be very large as the shader processor can consume the results at the same rate that the Texture Unit produces them.
</p><p>In our current configuration files the value of this parameter is set to 4 texture results (each texture results corresponds with a fragment quad).
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureWaitReadWindow"> TextureWaitReadWindow </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (window) where read operations to the Texture Cache remain until the corresponding Texture Cache line is received.
</p><p>This structure is used to support out of order processing of the texture requests.  After performing a texture request fetch all the required data from the Texture Cache it will either be moved to the queue for texture requests pending from reading the Texture Cache, if all the corresponding Texture Cache lines are already present, or to the wait window, if any line has to be requested to memory.  When the pending Texture Cache lines are received the texture requests are moved out of order to the read queue.
</p><p>Small sizes for this structure will likely reduce the out of order and latency hiding capabilities of the Texture Unit.
</p><p>The actual performance impact of this structure has not been tested.  Also it has not been proved that texture requests are processed out of order.
</p><p>In the current implementation the value for this parameter is 128 texture requests (each texture requests corresponds with a fragment quad).
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TwoLevelTextureCache"> TwoLevelTextureCache </span></h3>
<p><b> Description </b>
</p><p>When the parameter is set to TRUE the Texture Cache is implemented as two caches.  The first cache, and smaller cache, holds uncompressed texture data and should have enough bandwidth to service all texels for a bilinear request for a fragment quad in a cycle (at least for 32-bit texture formats).  The second, larger to hide latency and to profit from texture access locality, holds uncompressed texture data and the bandwidth should be enough to keep the level one cache filled.
</p><p>When the parameter is set to FALSE the Texture Cache is implemented as a single cache.  The cache would hold uncompressed texture data.
</p><p>In the current implementation due to a large memory transaction size (64 bytes) when the parameter is set to FALSE the cache line size should be at least 256 bytes or memory bandwidth would be wasted for compressed textures (uncompressed size is x8 for DXT1, x4 for DXT3/DXT5).
</p><p>In our current configuration files the parameter is set to TRUE.
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="TextureCacheLineSize"> TextureCacheLineSize </span></h3>
<p><b> Description </b>
</p><p>When TwoLevelTextureCache is set to TRUE this parameter defines the size of the first level (L0) cache line in bytes.
</p><p>When TwoLevelTextureCache is set to FALSE this parameter defines the size of the Texture Cache line in bytes.
</p><p>In both cases the cache line size defined is for uncompressed data.  So take that into account depending on the actual size of the minimum request possible to the next memory level for possible loses of bandwidth due to the decompression ratio.
</p><p>Cache size is computed as&nbsp;:
</p>
<pre>TextureCacheWays * TextureCacheLines * TextureCacheLineSize
</pre>
<p>In our current configuration files the line size is set to 64 bytes.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureCacheWays"> TextureCacheWays </span></h3>
<p><b> Description </b>
</p><p>When TwoLevelTextureCache is set to TRUE this parameter defines the number of ways (associativity) in the first level (L0) cache.
</p><p>When TwoLevelTextureCache is set to FALSE this parameter defines the number of ways (associativity) in the Texture Cache.
</p><p>Cache size is computed as&nbsp;: 
</p>
<pre>TextureCacheWays * TextureCacheLines * TextureCacheLineSize
</pre>
<p>In our current configuration files this parameter is set to 8 ways.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureCacheLines"> TextureCacheLines </span></h3>
<p><b> Description </b>
</p><p>When TwoLevelTextureCache is set to TRUE this parameter defines the number of lines per way in the first level (L0) cache.
</p><p>When TwoLevelTextureCache is set to FALSE this parameter defines the number of lines per way ( in the Texture Cache.
</p><p>Cache size is computed as&nbsp;: 
</p>
<pre>TextureCacheWays * TextureCacheLines * TextureCacheLineSize
</pre>
<p>In our current configuration files this parameter is set to 8 ways.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureCachePortWidth"> TextureCachePortWidth </span></h3>
<p><b> Description </b>
</p><p>Defines how many bytes are read from each 'port' in the first level (L0) Texture Cache or when the Texture Cache is implemented as a single cache.  There are 4x4 ports (4 texel, 4 fragments) to service all the texels in a bilinear sample for a fragment quad in a single cycle without restrictions.
</p><p>In our current configuration files this parameter is set to 4 bytes.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureCacheRequestQueueSize"> TextureCacheRequestQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that stores cache line requests to memory.
</p><p>The buffer defined by this parameter is implemented in the FetchCache class and stores requests for texture misses (fills from memory and spills to memory if eviction is required, not the case for the Texture Cache).
</p><p>This buffer limits the maximum number of out-standing misses for the Texture Cache.  Given that the Texture Unit requires a large number of out-standing misses to completely hide memory latency a relatively large number of entries is required for good performance.
</p><p>When the TwoLevelTextureCache parameter is set to TRUE The value of this parameter is used for both instances of the FetchClass: one for the first level cache (L0) and another for the second level cache (L1).
</p><p>A propper performance evaluation of this parameter and the required number of out standing misses for the Texture Cache for a given memory configuration (latency) has not performed.
</p><p>In our current configuration files the value of this parameter is set to 128 misses.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureCacheInputQueue"> TextureCacheInputQueue </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that holds Texture Cache requests for misses.
</p><p>The buffer defined by this parameter is implemented in the TextureCache class.  The value of this parameter limits the number of outstanding misses supported by the Texture Cache.  The actual limit is the minimum of the value of this parameter and the value of the TextureCacheRequestQueueSize parameter.
</p><p>When TwoLevelTextureCache is set to TRUE this defines the size of the buffer for the first level cache (L0).
</p><p>The performance impact of this parameter and the actual number of outstanding misses required to completely hide the latency of a given memory configuration has not been propperly evaluated.
</p><p>In our current configuration files the value of this parameter is 128 misses.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureCacheMissesPerCycle"> TextureCacheMissesPerCycle </span></h3>
<p><b> Description </b>
</p><p>Defines how many misses can be generated per cycle by the Texture Cache.
</p><p>In a single cycle the Texture Cache supports up to 16 fetch operations (4 texels for a bilinear for 4 fragments).  If the number of misses for those 16 fetch operations exceed the value defined for this parameter the Texture Cache logic will iterate over the same group of 16 fetch operations untill all the required missed lines are enqueued in the miss buffers of the Texture Cache.
</p><p>The actual performance impact of this parameter has not been evaluated.
</p><p>In our current configuration files the value of this parameter is 8 misses.  Not sure if we use this value due to results from experiments or based on the analysis of actual hardware implementations.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureCacheDecompressLatency"> TextureCacheDecompressLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the latency in cycles of the texture decompression stage implemented in the Texture Cache.
</p><p>In the current implementation the texture decompression stage isn't pipelined so only a single cache line can be decompressed at a time.  Latencies greater than 1 reduce the throughput of the decompression stage and thus the actual bandwidth into the Texture Cache.  This may be changed in future implementations.
</p><p>In our current configuration files this parameter is set to 1 cycle.  The reason is that the current implementation doesn't model a pipelined texture decompression stage and a latency higher than 1 would greatly reduce the bandwidth into the Texture Cache.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureCacheLineSizeL1"> TextureCacheLineSizeL1 </span></h3>
<p><b> Description </b>
</p><p>When TwoLevelTextureCache is set to TRUE this parameter defines the size of the second level (L1) cache line in bytes. 
</p><p>When TwoLevelTextureCache is set to FALSE this parameter is not used.
</p><p>Lines in the second level cache may hold compressed texture data.
</p><p>Second level (L1) cache size is computed as&nbsp;:
</p>
<pre>TextureCacheWaysL1 * TextureCacheLinesL1 * TextureCacheLineSizeL1.
</pre>
<p>In our current configuration files the line size is set to 64 bytes.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureCacheWaysL1"> TextureCacheWaysL1 </span></h3>
<p>When TwoLevelTextureCache is set to TRUE this parameter defines the number of ways (associativity) in the second level (L1) cache. 
</p><p>When TwoLevelTextureCache is set to FALSE this parameter is not used. 
</p><p>Second level (L1) Texture Cache size is computed as&nbsp;:
</p>
<pre>TextureCacheWaysL1 * TextureCacheLinesL1 * TextureCacheLineSizeL1 
</pre>
<p>In our current configuration files this parameter is set to 8 ways.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureCacheLinesL1"> TextureCacheLinesL1 </span></h3>
<p><b> Description </b>
</p><p>When TwoLevelTextureCache is set to TRUE this parameter defines the number of lines per way in the second level (L1) cache. 
</p><p>When TwoLevelTextureCache is set to FALSE this parameter is not used. 
</p><p>Second level (L1) Texture Cache size is computed as&nbsp;: 
</p>
<pre>TextureCacheWaysL1 * TextureCacheLinesL1 * TextureCacheLineSizeL1 
</pre>
<p>In our current configuration files this parameter is set to 8 ways.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="TextureCacheInputQueueL1"> TextureCacheInputQueueL1 </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that holds Texture Cache requests for misses. 
</p><p>The buffer defined by this parameter is implemented in the TextureCache class. The value of this parameter limits the number of outstanding misses supported by the Texture Cache. The actual limit is the minimum of the value of this parameter and the value of the TextureCacheRequestQueueSize parameter. 
</p><p>When TwoLevelTextureCache is set to TRUE this defines the size of the buffer for the second level cache (L1). 
</p><p>When TwoLevelTextureCache is set to FALSE this parameter is not used.
</p><p>In the current implementation the value of this parameter and TextureCacheInputQueue (first level cache) may limit each other.  A propper evaluation of the current implementation is required.
</p><p>The performance impact of this parameter and the actual number of outstanding misses required to completely hide the latency of a given memory configuration has not been propperly evaluated. 
</p><p>In our current configuration files the value of this parameter is 128 misses.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h1> <span class="mw-headline" id="ZSTENCILTEST_section"> ZSTENCILTEST section </span></h1>
<h2> <span class="mw-headline" id="ROPZ_parameters"> ROPZ parameters </span></h2>
<h3> <span class="mw-headline" id="StampsPerCycle_.28ROPZ.29"> StampsPerCycle (ROPZ) </span></h3>
<p><b> Description </b>
</p><p>Defines the number of fragment quads per cycle that the Z and Stencil Test unit (ROPZ) can receive from and return back to Fragment FIFO.
</p><p>In the current implementation the Z and Stencil Test unit (ROPZ) internal throughput is limited to a single fragment quad per cycle and when multisampling antialiasing is enabled to a single sample per fragment read or written to the Z Cache.  This may change in future implementations.
</p><p>The value of this parameter should match the value defined for the StampsPerCycle (RASTERIZER section) divided by the value defined by the NumStampPipes parameter (GPU section).
</p><p>In our current configuration files this parameter is set to 1 fragment quad.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BytesPerPixel_.28ROPZ.29"> BytesPerPixel (ROPZ) </span></h3>
<p><b> Description </b>
</p><p>In the original implementation this value represented the bytes per fragment for depth+stencil.  In the current implementation this parameter is deprecated (the bit depth of the depth stencil buffer may be fixed or configurable through a GPU register) and not longer used.
</p><p>This parameter will be eventually removed.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h2> <span class="mw-headline" id="Z_Cache_parameters"> Z Cache parameters </span></h2>
<h3> <span class="mw-headline" id="ZCacheWays"> ZCacheWays </span></h3>
<p><b> Description </b>
</p><p>Defines the number of ways (associativity) of the Z Cache.
</p><p>The Z Cache size is computed as&nbsp;:
</p>
<pre>ZCacheWays * ZCacheLines * ZCacheStampsPerLine * 16
</pre>
<p>In the current implementation this parameter is set to 4 ways (Z Cache size of 16 KBs).
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ZCacheLines"> ZCacheLines </span></h3>
<p><b> Description </b>
</p><p>Defines the number of line per way of the Z Cache.
</p><p>The Z Cache size is computed as&nbsp;: 
</p>
<pre>ZCacheWays * ZCacheLines * ZCacheStampsPerLine * 16
</pre>
<p>In our current configuration files this parameter is set to 16 lines (Z Cache size of 16 KBs).
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ZCacheStampsPerLine"> ZCacheStampsPerLine </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the Z Cache lines.
</p><p>In the current implementation the size is defined as number of fragment quads (2x2 fragments) for 32-bit (4 bytes) fragments.  The actual cache line size in bytes can be obtained by multiplying the value assigned to this parameter by 16 bytes.
</p><p>The Z Cache size is computed as&nbsp;: 
</p>
<pre>ZCacheWays * ZCacheLines * ZCacheStampsPerLine * 16
</pre>
<p>In our current configuration files this parameter is set to 16 (256 bytes per cache line, total 16 KBs for the Z Cache).
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ZCachePortWidth"> ZCachePortWidth </span></h3>
<p><b> Description </b>
</p><p>Defines how many bytes can be read or write through the Z Cache ports.  Defines the bandwidth between the Z Cache and the Z and Stencil Test unit.
</p><p>As the Z and Stencil Test unit can process one fragment quad per cycle for 32-bit (4 bytes) per fragment depth+stencil the minimum bandwidth required with the Z cache for read or write operations is 16 bytes.
</p><p>In our current implementation this parameter is set to 32 bytes.  I think that with the current implementation the value should be 16.  The current value would valid if the Z and Stencil Test unit could read or write two samples per cycle but that's not the case.  Likely the implementation will change to fix this limitation.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ZCacheExtraReadPort"> ZCacheExtraReadPort </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE an extra read port is modeled in the Z Cache.  This allows for a read operation from Z and Stencil Test unit in parallel with a read for a Z cache line eviction.
</p><p>When the Z cache was first implemented it was detected that without the two read and two write ports the performance reduction due to contention from cache line evictions and fills was quite noticeable.  This feature and parameter were added to prevent that performance reduction.
</p><p>In our current configuration files this parameter is set to TRUE.  Eventually a more realistic model should be implemented but some mechanism (banked cache) to reduce contention may be required.
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="ZCacheExtraWritePort"> ZCacheExtraWritePort </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE an extra write port is modeled in the Z Cache. This allows for a write operation from Z and Stencil Test unit in parallel with a write for a Z cache line fill. 
</p><p>When the Z cache was first implemented it was detected that without the two read and two write ports the performance reduction due to contention from cache line evictions and fills was quite noticeable. This feature and parameter were added to prevent that performance reduction. 
</p><p>In our current configuration files this parameter is set to TRUE. Eventually a more realistic model should be implemented but some mechanism (banked cache) to reduce contention may be required.
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="ZCacheRequestQueueSize"> ZCacheRequestQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that stores misses while they are being serviced.
</p><p>This buffer is implemented in the FetchCache class and each entry stores information for both the spill (eviction) and fill (miss service) associated with the miss.
</p><p>This value assigned to this parameter limits the number of outstanding misses supported by the Z Cache.  This number affects the memory latency hiding capability of the Z and Stencil Test stage.
</p><p>It has been evaluated that a reduced number of outstanding misses reduces the performance of the Memory Controller.
</p><p>In our current configuration files this parameter is set to 128 misses.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ZCacheInputQueueSize"> ZCacheInputQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that stores cache line fill operations while they are being serviced from memory. 
</p><p>This buffer is implemented in the ROPCache class and each entry stores information cache line fill operations associated with a cache miss. 
</p><p>This value assigned to this parameter limits the number of outstanding misses supported by the Z Cache. This number affects the memory latency hiding capability of the Z and Stencil Test stage. 
</p><p>It has been evaluated that a reduced number of outstanding misses reduces the performance of the Memory Controller. 
</p><p>In our current configuration files this parameter is set to 128 misses.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ZCacheOutputQueueSize"> ZCacheOutputQueueSize </span></h3>
<p>Defines the size of the buffer (FIFO) that stores cache line spill (eviction) operations while they are being serviced to memory. 
</p><p>This buffer is implemented in the ROPCache class and each entry stores information cache line spill operations associated with a cache miss. 
</p><p>This value assigned to this parameter limits the number of outstanding misses supported by the Z Cache. This number affects the memory latency hiding capability of the Z and Stencil Test stage. 
</p><p>It has been evaluated that a reduced number of outstanding misses reduces the performance of the Memory Controller. 
</p><p>In our current configuration files this parameter is set to 128 misses.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BlockStateMemorySize_.28ROPZ.29"> BlockStateMemorySize (ROPZ) </span></h3>
<p><b> Description </b>
</p><p>Defines for how many framebuffer blocks (1 block = 1 cache line) the Z cache can hold the compression and clear state.
</p><p>For framebuffer compression and fast clear support the Z Cache stores a per cache line (framebuffer block) value of a few bits (for example, 2 to 4 bits) that defines the current state of corresponding cache line (framebuffer block) as stored in memory: cleared, compressed with different compression ratios or algorithms or uncompressed.
</p><p>In the current implementation the total size of the block state memory through all the Z Caches limits the maximum size of the depth+stencil buffer with fast clear, compression and Hierarchical Z buffer support.
</p><p>Take into account that when multisampling antialising is enabled the maximum size of the framebuffer in terms of pixel resolution decreases as the size in bytes of a framebuffer block (cache line) doesn't change.
</p><p>In the current implementation this parameter is set to 262144 blocks.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BlocksClearedPerCycle_.28ROPZ.29"> BlocksClearedPerCycle (ROPZ) </span></h3>
<p><b> Description </b>
</p><p>Defines the number of blocks for which the state can be cleared per cycle in the block state memory of the Z Cache.  Defines how fast the fast clear operation is actually performed.
</p><p>As a block state requires only 2 to 4 bits clearing (actually writing) a relatively large number of values per cycle may be possible.
</p><p>Fast clear operations are already fast due to using an internal state memory and clearing blocks, not pixels, so for performance the number of blocks cleared per cycle doesn't need to be that large.
</p><p>In our current configuration files this parameter is set to 1024 blocks.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="DisableCompression_.28ROPZ.29"> DisableCompression (ROPZ) </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE compression of cache lines (1 cache line = 1 depth+stencil buffer block = 1 HZ buffer block) when are evicted to memory is disabled.
</p><p>This parameter has a considerable performance effect due to the increase in bandwidth required with memory and because when Z Cache compression is disabled the Hierarchical Z test has to be disabled (DisableHZ parameter in RASTERIZER section).
</p><p>In our current configuration files this parameter is set to FALSE.
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="CompressionAlgorithm_.28ROPZ.29"> CompressionAlgorithm (ROPZ) </span></h3>
<p><b> Description </b>
</p><p>Defines the compression algorithm that is used to compress Z Cache lines evicted to memory.
</p><p>Currently implemented compression algorithms are:
</p>
<ul><li> 0&nbsp;: HiLo algorithm (original).  The implemented algorithm is actually suitable only for depth compression and the presence of varying stencil values will greatly reduce performance.  The algorithm is based on an ATI patent for depth compression.  Two reference depth values are stored per block and two extra depth values are derived from the reference depth values.  These four values are used as the high (MSB) bits of the block depth values.  The block depth values are compressed as indices to one of these four depth values and an offset (lower bits, LSB).  Only two compression ratios are supported: 2x, 4x.
</li><li> 1&nbsp;: An enhanced implementation of the HiLo algorithm that supports up to 3 compression ratios and rearranging the MSB and LSB relative to the different fragment/sample fields (stencil/depth or R/G/B/A).  Iplemented by Christian, look at code and his Master Thesis for details.
</li><li> 2&nbsp;: MSAA compression algorithm.  Implemented by Christian, look at code and his Master Thesis for details.
</li></ul>
<p>For the Z Cache only a specialized version of the HiLo algorithm for depth and 3 compression ratios is currently implemented.  The compression algorithm code is 0.  Therefore this parameter can only be set to 0.
</p><p>In our current configuration files this parameter is set to 0.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="CompressionUnitLatency_.28ROPZ.29"> CompressionUnitLatency (ROPZ) </span></h3>
<p><b> Description </b>
</p><p>Defines the number of cycles required to compress a Z Cache line that is being evicted to memory.
</p><p>In the current implementation the modeled compression stage is not pipelined.  The value assigned to this parameter may reduce the actual bandwidth from the Z Cache to the Memory Controller.
</p><p>In our current configuration files this parameter is set to 8 cycles.  Note that given a cache line size of 256 bytes and a maximum bandwidth to the Memory Controller of 64 bytes per cycle the actual bandwidth is reduced to 32 bytes per cycle with this value.  However the Z Cache can compress a cache line and decompress another cache line in parallel so the maximum bandwidth with the Memory Controller can actually be maxed.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="DecompressionUnitLatency_.28ROPZ.29"> DecompressionUnitLatency (ROPZ) </span></h3>
<p><b> Description </b>
</p><p>Defines the number of cycles required to decompress a Z Cache line that is being evicted to memory.
</p><p>In the current implementation the modeled decompression stage is not pipelined.  The value assigned to this parameter may reduce the actual bandwidth from the Z Cache to the Memory Controller.
</p><p>In our current configuration files this parameter is set to 8 cycles.  Note that given a cache line size of 256 bytes and a maximum bandwidth to the Memory Controller of 64 bytes per cycle the actual bandwidth is reduced to 32 bytes per cycle with this value.  However the Z Cache can compress a cache line and decompress another cache line in parallel so the maximum bandwidth with the Memory Controller can actually be maxed.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="InputQueueSize_.28ROPZ.29"> InputQueueSize (ROPZ) </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that stores fragment quads received from the Fragment FIFO (Shader Work Distributor) stage.
</p><p>From this queue the fragment quads are issued to the Z Cache fetch/allocate stage.
</p><p>In our current configuration files this parameter is set to 8 fragment quads.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="FetchQueueSize_.28ROPZ.29"> FetchQueueSize (ROPZ) </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that stores fragment quads that already peformed the Z cache fetch/allocate operation and are waiting to read data from the cache.
</p><p>This buffer is the main limit to the memory latency capability of the Z and Stencil Test stage so it should be relatively large.
</p><p>In our current implementation this parameter is set to 256 fragment quads.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ReadQueueSize_.28ROPZ.29"> ReadQueueSize (ROPZ) </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that stores fragment quads that already read data from the Z cache and are waiting to performe the Z and Stencil test.
</p><p>In our current configuration files this parameter is set to 16 fragment quads.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="OpQueueSize_.28ROPZ.29"> OpQueueSize (ROPZ) </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that holds fragment quads that were already tested and are waiting to be write the results of the test back to the Z Cache.
</p><p>In our current configuration files this parameter is set to 4 fragment quads.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="WriteQueueSize"> WriteQueueSize </span></h3>
<p><b> Description (ROPZ) </b>
</p><p>Defines the size of the buffer (FIFO) that stores fully processed fragment quads that are waiting to be returned to the Fragment FIFO stage.
</p><p>In our current configuration files this parameter is set to 8 fragment quads.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ZALUTestRate"> ZALUTestRate </span></h3>
<p><b> Description </b>
</p><p>Defines the number of iterations (cycles) through the Z and Stencil Test ALUs required to process a fragment quad.
</p><p>In the current implementation this parameter is used to reduce the throughput of the Z and Stencil Test stage to less than one fragment quad per cycle.
</p><p>In our current configuration files this parameter is set to 1 cycle.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ZALULatency"> ZALULatency </span></h3>
<p><b> Description </b>
</p><p>Defines the latency in cycles of the Z and Stencil Test ALU that implements the tests.
</p><p>In our current configuration files this parameter is set to 2 cycles.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h1> <span class="mw-headline" id="COLORWRITE_section"> COLORWRITE section </span></h1>
<h2> <span class="mw-headline" id="ROPC_parameters"> ROPC parameters </span></h2>
<h3> <span class="mw-headline" id="StampsPerCycle_.28ROPC.29"> StampsPerCycle (ROPC) </span></h3>
<p>Defines the number of fragment quads per cycle that the Color Write unit (ROPC) can receive from  Fragment FIFO. 
</p><p>In the current implementation the Color Write unit (ROPC) internal throughput is limited to a single fragment quad per cycle and when multisampling antialiasing is enabled to a single sample per fragment read or written to the Color Cache. This may change in future implementations. 
</p><p>The value of this parameter should match the value defined for the StampsPerCycle (RASTERIZER section) divided by the value defined by the NumStampPipes parameter (GPU section). 
</p><p>In our current configuration files this parameter is set to 1 fragment quad.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BytesPerPixel_.28ROPC.29"> BytesPerPixel (ROPC) </span></h3>
<p><b> Description </b>
</p><p>In the original implementation this value represented the bytes per fragment for color. In the current implementation this parameter is deprecated (the bit depth of the color buffer may be fixed or configurable through a GPU register) and not longer used. 
</p><p>This parameter will be eventually removed.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h2> <span class="mw-headline" id="Color_Cache_parameters"> Color Cache parameters </span></h2>
<h3> <span class="mw-headline" id="ColorCacheWays"> ColorCacheWays </span></h3>
<p><b> Description </b>
</p><p>Defines the number of ways (associativity) of the Color Cache.
</p><p>The Color Cache size is computed as&nbsp;:
</p>
<pre>ColorCacheWays * ColorCacheLines * ColorCacheStampsPerLine * 16
</pre>
<p>In the current implementation this parameter is set to 4 ways (Color Cache size of 16 KBs). 
</p><p><br>
<b> Format </b> 
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ColorCacheLines"> ColorCacheLines </span></h3>
<p><b> Description </b>
</p><p>Defines the number of line per way of the Color Cache.
</p><p>The Color Cache size is computed as&nbsp;:
</p>
<pre>ColorCacheWays * ColorCacheLines * ColorCacheStampsPerLine * 16
</pre>
<p>In our current configuration files this parameter is set to 16 lines (Color Cache size of 16 KBs). 
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ColorCacheStampsPerLine"> ColorCacheStampsPerLine </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the Color Cache lines.
</p><p>In the current implementation the size is defined as number of fragment quads (2x2 fragments) for 32-bit (4 bytes) fragments. The actual cache line size in bytes can be obtained by multiplying the value assigned to this parameter by 16 bytes.
</p><p>The Z Cache size is computed as&nbsp;:
</p>
<pre>ColorCacheWays * ColorCacheLines * ColorCacheStampsPerLine * 16
</pre>
<p>In our current configuration files this parameter is set to 16 (256 bytes per cache line, total 16 KBs for the Color Cache). 
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ColorCachePortWidth"> ColorCachePortWidth </span></h3>
<p><b> Description </b>
</p><p>Defines how many bytes can be read or write through the Color Cache ports. Defines the bandwidth between the Color Cache and the Color Write unit.
</p><p>As the Color Write unit can process one fragment quad per cycle for 32-bit (4 bytes) per fragment color the minimum bandwidth required with the Color cache for read or write operations is 16 bytes.
</p><p>In our current implementation this parameter is set to 32 bytes. I think that with the current implementation the value should be 16. The current value would valid if the Color Write unit could read or write two samples per cycle but that's not the case. Likely the implementation will change to fix this limitation. 
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ColorCacheExtraReadPort"> ColorCacheExtraReadPort </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE an extra read port is modeled in the Color Cache. This allows for a read operation from Color Write unit in parallel with a read for a Color cache line eviction.
</p><p>When the Color cache was first implemented it was detected that without the two read and two write ports the performance reduction due to contention from cache line evictions and fills was quite noticeable. This feature and parameter were added to prevent that performance reduction.
</p><p>In our current configuration files this parameter is set to TRUE. Eventually a more realistic model should be implemented but some mechanism (banked cache) to reduce contention may be required.
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="ColorCacheExtraWritePort"> ColorCacheExtraWritePort </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE an extra write port is modeled in the Color Cache. This allows for a write operation from Color Write unit in parallel with a write for a Color cache line fill.
</p><p>When the Color cache was first implemented it was detected that without the two read and two write ports the performance reduction due to contention from cache line evictions and fills was quite noticeable. This feature and parameter were added to prevent that performance reduction.
</p><p>In our current configuration files this parameter is set to TRUE. Eventually a more realistic model should be implemented but some mechanism (banked cache) to reduce contention may be required. 
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="ColorCacheRequestQueueSize"> ColorCacheRequestQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that stores misses while they are being serviced.
</p><p>This buffer is implemented in the FetchCache class and each entry stores information for both the spill (eviction) and fill (miss service) associated with the miss.
</p><p>This value assigned to this parameter limits the number of outstanding misses supported by the Color Cache. This number affects the memory latency hiding capability of the Color Write stage.
</p><p>It has been evaluated that a reduced number of outstanding misses reduces the performance of the Memory Controller.
</p><p>In our current configuration files this parameter is set to 128 misses. 
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ColorCacheInputQueueSize"> ColorCacheInputQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that stores cache line fill operations while they are being serviced from memory.
</p><p>This buffer is implemented in the ROPCache class and each entry stores information cache line fill operations associated with a cache miss.
</p><p>This value assigned to this parameter limits the number of outstanding misses supported by the Color Cache. This number affects the memory latency hiding capability of the Color Write stage.
</p><p>It has been evaluated that a reduced number of outstanding misses reduces the performance of the Memory Controller.
</p><p>In our current configuration files this parameter is set to 128 misses. 
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ColorCacheOutputQueueSize"> ColorCacheOutputQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that stores cache line spill (eviction) operations while they are being serviced to memory.
</p><p>This buffer is implemented in the ROPCache class and each entry stores information cache line spill operations associated with a cache miss.
</p><p>This value assigned to this parameter limits the number of outstanding misses supported by the Color Cache. This number affects the memory latency hiding capability of the Color Write stage.
</p><p>It has been evaluated that a reduced number of outstanding misses reduces the performance of the Memory Controller.
</p><p>In our current configuration files this parameter is set to 128 misses. 
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BlockStateMemorySize_.28ROPC.29"> BlockStateMemorySize (ROPC) </span></h3>
<p><b> Description </b>
</p><p>Defines for how many framebuffer blocks (1 block = 1 cache line) the Color cache can hold the compression and clear state.
</p><p>For framebuffer compression and fast clear support the Color Cache stores a per cache line (framebuffer block) value of a few bits (for example, 2 to 4 bits) that defines the current state of corresponding cache line (framebuffer block) as stored in memory: cleared, compressed with different compression ratios or algorithms or uncompressed.
</p><p>In the current implementation the total size of the block state memory through all the Color Caches limits the maximum size of the color buffer with fast clear and compression support.
</p><p>Take into account that when multisampling antialising is enabled the maximum size of the framebuffer in terms of pixel resolution decreases as the size in bytes of a framebuffer block (cache line) doesn't change.
</p><p>In the current implementation this parameter is set to 262144 blocks. 
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BlocksClearedPerCycle_.28ROPC.29"> BlocksClearedPerCycle (ROPC) </span></h3>
<p><b> Description </b>
</p><p>Defines the number of blocks for which the state can be cleared per cycle in the block state memory of the Color Cache. Defines how fast the fast clear operation is actually performed.
</p><p>As a block state requires only 2 to 4 bits clearing (actually writing) a relatively large number of values per cycle may be possible.
</p><p>Fast clear operations are already fast due to using an internal state memory and clearing blocks, not pixels, so for performance the number of blocks cleared per cycle doesn't need to be that large.
</p><p>In our current configuration files this parameter is set to 1024 blocks. 
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="DisableCompression_.28ROPC.29"> DisableCompression (ROPC) </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE compression of cache lines (1 cache line = 1 color buffer block) when are evicted to memory is disabled.
</p><p>This parameter has a considerable performance effect due to the increase in bandwidth required with memory.
</p><p>In our current configuration files this parameter is set to FALSE. 
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="CompressionAlgorithm_.28ROPC.29"> CompressionAlgorithm (ROPC) </span></h3>
<p><b> Description </b>
</p><p>Defines the compression algorithm that is used to compress Color Cache lines evicted to memory.
</p><p>Currently implemented compression algorithms are:
</p>
<pre>   * 0&nbsp;: HiLo algorithm (original). The implemented algorithm is actually suitable only for depth compression and the presence of varying stencil values will greatly reduce performance. The algorithm is based on an ATI patent for depth compression. Two reference depth values are stored per block and two extra depth values are derived from the reference depth values. These four values are used as the high (MSB) bits of the block depth values. The block depth values are compressed as indices to one of these four depth values and an offset (lower bits, LSB). Only two compression ratios are supported: 2x, 4x.
   * 1&nbsp;: An enhanced implementation of the HiLo algorithm that supports up to 3 compression ratios and rearranging the MSB and LSB relative to the different fragment/sample fields (stencil/depth or R/G/B/A). Implemented by Christian, look at code and his Master Thesis for details.
   * 2&nbsp;: MSAA compression algorithm. Implemented by Christian, look at code and his Master Thesis for details. 
</pre>
<p>In our current configuration files this parameter is set to 0. 
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="CompressionUnitLatency_.28ROPC.29"> CompressionUnitLatency (ROPC) </span></h3>
<p><b> Description </b>
</p><p>Defines the number of cycles required to compress a Color Cache line that is being evicted to memory.
</p><p>In the current implementation the modeled compression stage is not pipelined. The value assigned to this parameter may reduce the actual bandwidth from the Color Cache to the Memory Controller.
</p><p>In our current configuration files this parameter is set to 8 cycles. Note that given a cache line size of 256 bytes and a maximum bandwidth to the Memory Controller of 64 bytes per cycle the actual bandwidth is reduced to 32 bytes per cycle with this value. However the Color Cache can compress a cache line and decompress another cache line in parallel so the maximum bandwidth with the Memory Controller can actually be maxed.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="DecompressionUnitLatency"> DecompressionUnitLatency </span></h3>
<p><b> Description (ROPC) </b>
</p><p>Defines the number of cycles required to decompress a Color Cache line that is being evicted to memory.
</p><p>In the current implementation the modeled decompression stage is not pipelined. The value assigned to this parameter may reduce the actual bandwidth from the Color Cache to the Memory Controller.
</p><p>In our current configuration files this parameter is set to 8 cycles. Note that given a cache line size of 256 bytes and a maximum bandwidth to the Memory Controller of 64 bytes per cycle the actual bandwidth is reduced to 32 bytes per cycle with this value. However the Color Cache can compress a cache line and decompress another cache line in parallel so the maximum bandwidth with the Memory Controller can actually be maxed.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="InputQueueSize_.28ROPC.29"> InputQueueSize (ROPC) </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that stores fragment quads received from the Fragment FIFO (Shader Work Distributor) stage.
</p><p>From this queue the fragment quads are issued to the Color Cache fetch/allocate stage.
</p><p>In our current configuration files this parameter is set to 8 fragment quads. 
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="FetchQueueSize_.28ROPC.29"> FetchQueueSize (ROPC) </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that stores fragment quads that already peformed the Color cache fetch/allocate operation and are waiting to read data from the cache.
</p><p>This buffer is the main limit to the memory latency capability of the Color Write stage so it should be relatively large.
</p><p>In our current implementation this parameter is set to 256 fragment quads. 
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="ReadQueueSize_.28ROPC.29"> ReadQueueSize (ROPC) </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that stores fragment quads that already read data from the Color cache and are waiting to performe the color/blend operation.
</p><p>In our current configuration files this parameter is set to 16 fragment quads.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="OpQueueSize_.28ROPC.29"> OpQueueSize (ROPC) </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that holds fragment quads that were already operated/blended and are waiting to be write the results of the operation back to the Color Cache.
</p><p>In our current configuration files this parameter is set to 4 fragment quads. 
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="WriteQueueSize_.28ROPC.29"> WriteQueueSize (ROPC)  </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that stores fully processed fragment quads that are waiting to be eliminated (end of the fragment pipelined) or returned to the Fragment FIFO stage.
</p><p>In our current configuration files this parameter is set to 8 fragment quads. 
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BlendALUTestRate"> BlendALUTestRate </span></h3>
<p><b> Description </b>
</p><p>Defines the number of iterations (cycles) through the Color Blend ALUs required to process a fragment quad.
</p><p>In the current implementation this parameter is used to reduce the throughput of the Color Write stage to less than one fragment quad per cycle.
</p><p>In our current configuration files this parameter is set to 1 cycle. 
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BlendALULatency"> BlendALULatency </span></h3>
<p><b> Description </b>
</p><p>Defines the latency in cycles of the Color Blend ALU that implements the color and blend operations.
</p><p>In our current configuration files this parameter is set to 2 cycles. 
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h1> <span class="mw-headline" id="DAC_section"> DAC section </span></h1>
<h3> <span class="mw-headline" id="BytesPerPixel_.28DAC.29"> BytesPerPixel (DAC) </span></h3>
<p><b> Description </b>
</p><p>In the original implementation this parameter defined the bits (actually bytes) per fragment in the color buffer.  The current implementation defines the bit depth of the color buffer format using a GPU register so this parameter has been deprecated and is no longer used.
</p><p>This parameter will eventually removed.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BlockSize"> BlockSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of framebuffer block in bytes.  A framebuffer block corresponds with a Z Cache and Color Cache line.
</p><p>In the current implementation the value of this parameter should match the cache line size for the Z Cache and Color Cache (or at least for the Color Cache).  In future implementations the actual cache line size will be directly passed to the DAC and this parameter will be removed.
</p><p>In our current configuration files this parameter is set to 256 bytes (matching Z Cache and Color Cache line sizes).
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BlockUpdateLatency"> BlockUpdateLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the latency in cycles for the block state memory updates received from the Color Cache.
</p><p>In the current implementation the value of this parameter is the latency assigned to the signal between the Color Write units and the DAC that is used to pass the updates of the block state memory when a frame is finished.
</p><p>We are not currently modeling a real DAC and the DAC unit is only used to dump the frames to a file for verification so realistic performance is not a current objective.  In any case the block state memory should be accessable (through copies or direct access) to the DAC in a real implementation.
</p><p>In our current configuration files this parameter is set to 1.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BlocksUpdatedPerCycle"> BlocksUpdatedPerCycle </span></h3>
<p><b> Description </b>
</p><p>Defines how many block state values can be received/stored per cycle from the Color Write units.
</p><p>In the current implementation this parameter is set to 1024 blocks.  Note that at 2 or 4 bits per block state value that's 256 or 512 bytes per cycle.
</p><p><b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="BlockRequestQueueSize"> BlockRequestQueueSize </span></h3>
<p><b> Description </b>
</p><p>Defines the size of the buffer (FIFO) that stores information for framebuffer blocks that are being requested to memory and decompressed.
</p><p>In our current configuration files this parameter is set to 32 blocks.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="DecompressionUnitLatency_2"> DecompressionUnitLatency </span></h3>
<p><b> Description </b>
</p><p>Defines the number of cycles required to decompress a framebuffer block.
</p><p>The decompression stage in the DAC is not modeled as a pipelined unit so a value higher than 1 reduces the throughput of this stage and the effective bandwidth at which data for framebuffer blocks is read.
</p><p>In our current configuration files this parameter is set to 1 cycle.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="RefreshRate"> RefreshRate </span></h3>
<p><b> Description </b>
</p><p>Defines the screen refresh rate in cycles.  Defines the frequency at which the DAC unit reads, decompresses and resolved the color buffer and sends the data to a display device (in the actual implementation a file in PPM format).
</p><p>Only if SynchedRefresh is set to FALSE will the the value of this parameter be used to trigger the screen refresh operation in the DAC unit.
</p><p>The current implementation of the DAC unit isn't used to correctly model a real DAC or the real costs of the screen refresh operation in memory bandwidth and strict timing requirements (refresh frequency, VBlank, HBlank, etc).  For this reason the normal refresh mode, trigger the screen refresh operation based on a given frequency, is not really used in our current simulations and the feature has not been fully tested nor used for a long time.
</p><p>This parameter was defined before the GPUClock parameter (GPU section) was implemented when there was no concept of 'real' time (defined as a base frequency) in the simulator.  For this reason the refresh rate is defined in cycles.  A likely change if we decide to model a real DAC will be to modify this parameter to define the actual refresh frequency in HZ rather than in cycles.
</p><p>In our current configuration files this parameter is set to 5000000 cycles.
</p><p><br>
<b> Format </b>
</p><p>Integer
</p>
<h3> <span class="mw-headline" id="SynchedRefresh"> SynchedRefresh </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE the DAC will 'refresh the screen', actually dump the current color buffer into a file (in PPM format), is synchronized with the frame end (framebuffer swap command).
</p><p>When this parameter is set to FALSE the DAC will 'refresh the screen' at the given rate defined by the RefreshRate parameter.  This refresh mode would be the correct as implemented by real DAC units to send the framebuffer data to a screen or monitor.
</p><p>The main purpose of this parameter is to be used to dump the framebuffer content after rendering has finished for debugging and validation purpose.
</p><p>In the current implementation the DAC unit purpose isn't to accurately simulate the screen refresh and associated memory bandwidth and strict timing requirements.  The normal refresh mode for this reason is only partially tested and has not been used for a long time.
</p><p>In our current configuration files this parameter is set to TRUE.
</p><p><br>
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="RefreshFrame"> RefreshFrame </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE 'screen refresh' is enabled in the DAC.
</p><p>In the current implementation 'screen refresh' is implemented with the DAC unit reading, decompressing and resolving (when MSAA is enabled) the framebuffer to the final on screen image as fast as possible and dumping the contents to a file (in PPM format). The main use is to validate the simulation by checking the resulting image.
</p><p>In the current implementation the purpose of the DAC unit isn't to implement the correct screen refresh operation with the associated memory bandwidth and strict timing requirements.
</p><p>In our current configuration files this parameter is set to TRUE.
</p><p><br>
</p><p><b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<h3> <span class="mw-headline" id="SaveBlitSourceData"> SaveBlitSourceData </span></h3>
<p><b> Description </b>
</p><p>When this parameter is set to TRUE the source data for all blits operations (using the Blitter unit) is dumped into a file (in PPM format).
</p><p>The purpose of this feature is/was to help in the debug of the Blitter.  It can also be used to log the usage of the Blitter operation (copy to texture in OpenGL).
</p><p>In our current configuration this parameter is set to FALSE.
</p><p><br>
<b> Format </b>
</p><p>Boolean (TRUE/FALSE)
</p>
<!-- 
NewPP limit report
Preprocessor node count: 1371/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:2463-0!1!0!!en!2!edit=0 and timestamp 20120702013520 -->
<div class="printfooter">
Retrieved from "<a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public">http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public</a>"</div>
				<!-- /bodytext -->
								<!-- catlinks -->
				<div id="catlinks" class="catlinks catlinks-allhidden"></div>				<!-- /catlinks -->
												<div class="visualClear"></div>
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<!-- header -->
		<div id="head" class="noprint">
			
<!-- 0 -->
<div id="p-personal" class="">
	<h5>Personal tools</h5>
	<ul>
					<li id="pt-login"><a href="http://attila.ac.upc.edu/wiki/index.php?title=Special:UserLogin&returnto=ATTILA_Configuration_File_Public" title="You are encouraged to log in; however, it is not mandatory [alt-o]" accesskey="o">Log in</a></li>
			</ul>
</div>

<!-- /0 -->
			<div id="left-navigation">
				
<!-- 0 -->
<div id="p-namespaces" class="vectorTabs">
	<h5>Namespaces</h5>
	<ul>
					<li id="ca-nstab-main" class="selected"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public" title="View the content page [alt-c]" accesskey="c"><span>Page</span></a></li>
					<li id="ca-talk" class="new"><a href="http://attila.ac.upc.edu/wiki/index.php?title=Talk:ATTILA_Configuration_File_Public&action=edit&redlink=1" title="Discussion about the content page [alt-t]" accesskey="t"><span>Discussion</span></a></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" class="vectorMenu emptyPortlet">
	<h5><span>Variants</span><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
			</div>
			<div id="right-navigation">
				
<!-- 0 -->
<div id="p-views" class="vectorTabs">
	<h5>Views</h5>
	<ul>
					<li id="ca-view" class="selected"><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public"><span>Read</span></a></li>
					<li id="ca-viewsource"><a href="http://attila.ac.upc.edu/wiki/index.php?title=ATTILA_Configuration_File_Public&action=edit" title="This page is protected.
You can view its source [alt-e]" accesskey="e"><span>View source</span></a></li>
					<li id="ca-history" class="collapsible "><a href="http://attila.ac.upc.edu/wiki/index.php?title=ATTILA_Configuration_File_Public&action=history" title="Past revisions of this page [alt-h]" accesskey="h"><span>View history</span></a></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" class="vectorMenu emptyPortlet">
	<h5><span>Actions</span><a href="http://attila.ac.upc.edu/wiki/index.php/ATTILA_Configuration_File_Public#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id="p-search">
	<h5><label for="searchInput">Search</label></h5>
	<form action="http://attila.ac.upc.edu/wiki/index.php" id="searchform">
		<input type="hidden" name="title" value="Special:Search">
				<input id="searchInput" name="search" type="text" title="Search AttilaWiki [alt-f]" accesskey="f" value="">
		<input type="submit" name="go" class="searchButton" id="searchGoButton" value="Go" title="Go to a page with this exact name if exists">
		<input type="submit" name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search the pages for this text">
			</form>
</div>

<!-- /2 -->
			</div>
		</div>
		<!-- /header -->
		<!-- panel -->
			<div id="panel" class="noprint">
				<!-- logo -->
					<div id="p-logo"><a style="background-image: url(/wiki/skins/common/images/kaluza_resized.png);" href="http://attila.ac.upc.edu/wiki/index.php/Main_Page" title="Visit the main page"></a></div>
				<!-- /logo -->
				
<!-- ATTILA -->
<div class="portal" id="p-ATTILA">
	<h5>ATTILA</h5>
	<div class="body">
				<ul>
					<li id="n-Project"><a href="http://attila.ac.upc.edu/wiki/index.php/Attila_Project">Project</a></li>
					<li id="n-The-Team"><a href="http://attila.ac.upc.edu/wiki/index.php/The_ATTILA_team">The Team</a></li>
					<li id="n-Architecture"><a href="http://attila.ac.upc.edu/wiki/index.php/Architecture">Architecture</a></li>
					<li id="n-Driver"><a href="http://attila.ac.upc.edu/wiki/index.php/Driver">Driver</a></li>
					<li id="n-Tools"><a href="http://attila.ac.upc.edu/wiki/index.php/Tools">Tools</a></li>
					<li id="n-Traces"><a href="http://attila.ac.upc.edu/traceList/">Traces</a></li>
					<li id="n-Publications"><a href="http://attila.ac.upc.edu/wiki/index.php/Publications">Publications</a></li>
					<li id="n-Downloads"><a href="http://attila.ac.upc.edu/wiki/index.php/Downloads">Downloads</a></li>
					<li id="n-Documentation"><a href="http://attila.ac.upc.edu/wiki/index.php/Documentation">Documentation</a></li>
					<li id="n-Links"><a href="http://attila.ac.upc.edu/wiki/index.php/Links">Links</a></li>
					<li id="n-Internal"><a href="http://attila.ac.upc.edu/wiki/index.php/Internal">Internal</a></li>
					<li id="n-Support-Attila"><a href="http://attila.ac.upc.edu/wiki/index.php/Support_Attila">Support Attila</a></li>
				</ul>
			</div>
</div>

<!-- /ATTILA -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
<div class="portal" id="p-tb">
	<h5>Toolbox</h5>
	<div class="body">
		<ul>
					<li id="t-whatlinkshere"><a href="http://attila.ac.upc.edu/wiki/index.php/Special:WhatLinksHere/ATTILA_Configuration_File_Public" title="List of all wiki pages that link here [alt-j]" accesskey="j">What links here</a></li>
						<li id="t-recentchangeslinked"><a href="http://attila.ac.upc.edu/wiki/index.php/Special:RecentChangesLinked/ATTILA_Configuration_File_Public" title="Recent changes in pages linked from this page [alt-k]" accesskey="k">Related changes</a></li>
																																										<li id="t-specialpages"><a href="http://attila.ac.upc.edu/wiki/index.php/Special:SpecialPages" title="List of all special pages [alt-q]" accesskey="q">Special pages</a></li>
									<li id="t-print"><a href="http://attila.ac.upc.edu/wiki/index.php?title=ATTILA_Configuration_File_Public&printable=yes" rel="alternate" title="Printable version of this page [alt-p]" accesskey="p">Printable version</a></li>
						<li id="t-permalink"><a href="http://attila.ac.upc.edu/wiki/index.php?title=ATTILA_Configuration_File_Public&oldid=10199" title="Permanent link to this revision of the page">Permanent link</a></li>
						</ul>
	</div>
</div>

<!-- /TOOLBOX -->

<!-- LANGUAGES -->

<!-- /LANGUAGES -->
			</div>
		<!-- /panel -->
		<!-- footer -->
		<div id="footer">
											<ul id="footer-info">
																	<li id="footer-info-lastmod"> This page was last modified on 9 January 2011, at 23:34.</li>
																							<li id="footer-info-viewcount">This page has been accessed 490 times.</li>
															</ul>
															<ul id="footer-places">
																	<li id="footer-places-privacy"><a href="http://attila.ac.upc.edu/wiki/index.php/AttilaWiki:Privacy_policy" title="AttilaWiki:Privacy policy">Privacy policy</a></li>
																							<li id="footer-places-about"><a href="http://attila.ac.upc.edu/wiki/index.php/AttilaWiki:About" title="AttilaWiki:About">About AttilaWiki</a></li>
																							<li id="footer-places-disclaimer"><a href="http://attila.ac.upc.edu/wiki/index.php/AttilaWiki:General_disclaimer" title="AttilaWiki:General disclaimer">Disclaimers</a></li>
															</ul>
										<ul id="footer-icons" class="noprint">
								<li id="footer-icon-poweredby"><a href="http://www.mediawiki.org/"><img src="./ATTILA Configuration File Public - AttilaWiki_files/poweredby_mediawiki_88x31.png" height="31" width="88" alt="Powered by MediaWiki"></a></li>
											</ul>
			<div style="clear:both"></div>
		</div>
		<!-- /footer -->
		<!-- fixalpha -->
		<script type="text/javascript"> if ( window.isMSIE55 ) fixalpha(); </script>
		<!-- /fixalpha -->
		
<script>if (window.runOnloadHook) runOnloadHook();</script>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script><script src="./ATTILA Configuration File Public - AttilaWiki_files/ga.js" type="text/javascript"></script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2004556-1");
pageTracker._trackPageview();
</script>		<!-- Served in 0.288 secs. -->			

</body></html>